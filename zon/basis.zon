/*
filename    basis
password    q7asq9
changedby   Whistler
EmailAdd     Whistler <whistler@blinksoft.com>
request     compile
version     86
END HEADER*/

/* *********************************************************************** *
 * File   : basis.zon                                 Part of Valhalla MUD *
 * Version: 1.20                                                           *
 * Author : seifert                                                        *
 *                                                                         *
 * Purpose: The basis zone.                                                *
 *                                                                         *
 * Bugs   : None known.                                                    *
 * Status : Published.                                                     *
 *                                                                         *
 * Copyright (C) 1994 - 1996 by Valhalla (This work is published).         *
 *                                                                         *
 * This work is a property of:                                             *
 *                                                                         *
 *        Valhalla I/S                                                     *
 *        Noerre Soegade 37A, 4th floor                                    *
 *        1370 Copenhagen K.                                               *
 *        Denmark                                                          *
 *                                                                         *
 * This work is copyrighted. No part of this work may be copied,           *
 * reproduced, translated or reduced to any medium without the prior       *
 * written consent of Valhalla.                                            *
 * *********************************************************************** */


#include <composed.h>

%zone                                  basis
reset RESET_NOT

weather 1040

creators {"papi"}

notes
"This is the basis zone. Dont let any rooms point to this zone, or use any
objects from this zone without special permission. Do not slime objects from
this zone."

help
"&hThis zone is not intended for players. Colour test (blue background):&n&n
&bb
&cnBlack.&n
&crRed.&n
&cgGreen.&n
&cyYellow.&n
&cbBlue.&n
&cmMagenta.&n
&ccCyan.&n
&cwWhite.&n
&c+nBright Black.&n
&c+rBright Red.&n
&c+gBright Green.&n
&c+yBright Yellow.&n
&c+bBright Blue.&n
&c+mBright Magenta.&n
&c+cBright Cyan.&n
&c+wBright White.&n
&bn
"

%dil

dilbegin aware catchit(pk:integer);
var
pc:unitptr;
code
{
:there:
wait (SFB_PRE,(( command (CMD_AUTO_DAMAGE)) and
(self==activator)));
if (target.type!=UNIT_ST_PC) goto there;
if ((isset (target.pcflags,PC_PK_RELAXED)) and
(pk==1)) goto there;
else
{
  power:=-1;
  block;
  }
  goto there;
}
dilend

dilbegin aware recall no_kill ();
code
{
interrupt (SFB_MSG,"remove kill prottection"==argument,dil_end);
interrupt (SFB_CMD,(( command (CMD_QUIT)) and ( self==activator)), dil_end);
interrupt (SFB_CMD,(( command (CMD_REMOVE)) and
("pk protection" ==argument) and
(self==activator)), dil_end);

heartbeat:=PULSE_SEC*600;
if (isset (self.pcflags, PC_PK_RELAXED))
  {
  unset (self.pcflags,PC_PK_RELAXED);
  act ("Due to your death you have been rewarded protection against PK for a short time.",
  A_ALWAYS,self,null,null,TO_CHAR);

  wait (SFB_TICK, TRUE);

  :dil_end:

  set (self.pcflags,PC_PK_RELAXED);
  act ("Your prottection from Pk has just worn off.",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }
else
  quit;
}
dilend


dilbegin integer carry_n_limit(ch : unitptr);
code
{
   return (10 + (ch.abilities[ABIL_DEX]) / 10);
}
dilend


dilbegin integer carry_w_limit(ch : unitptr);
var
   i : integer;
code
{
   i := ch.baseweight / 2;
   if (i < 50)
     i := 50;

   return (50 + i + ch.abilities[ABIL_STR]*2);
}
dilend


dilbegin deputy_check();
code
{
   :loop:
   wait(SFB_CMD, POLICE_ACADEMY in activator.quests);

   /* Lets not check for OUTLAW, since some weapons set it. Only if
      crimes > 0 will the player be banished (meaning that someone
      accused him) */

   if (activator.crimes > 0)
   {
      addextra(activator.quests, {POLICE_BANNED}, "");
      subextra(activator.quests, POLICE_ACADEMY);

      /* Clear all skills & spells taught by the law */

      activator.skills[SKI_CUFF] := 0;

      exec("say "+activator.name+", I am very disappointed in you, you "+
	   "can no longer consider yourself a deputy.", self);
   }

   goto loop;
}
dilend


/* Put in here all actions that need to be considered */
/* by players in Valhalla                             */
dilbegin dead_only(msg : string);
code
{
   :start:
   wait(SFB_CMD, activator.type == UNIT_ST_PC);
   if (activator.level >= ADMINISTRATOR_LEVEL)
     goto start;

   if (not isset(activator.pcflags, PC_SPIRIT))
   {
      act(msg, A_ALWAYS, activator, null, null, TO_CHAR);
      act("$1n vanishes in a flash of light!",
	  A_HIDEINV, activator, null, null, TO_ROOM);

      link(activator, findroom(activator.hometown));

      act("$1n materializes.", A_HIDEINV, activator, null, null, TO_ROOM);
      block;
      goto start;
   }

   if (command(CMD_CAST))
   {
      act("Your powers do not work in the spirit world!",
	  A_ALWAYS, activator, null, null, TO_CHAR);
      block;
   }
   else if (command(CMD_KILL) or command(CMD_HIT) or command(CMD_KICK) or
	    command(CMD_BASH) or command(CMD_BACKSTAB) or
	    command(CMD_TRIP) or command (CMD_DISARM))
   {
      act("Return to the mortal world, then you can die again.",
	  A_ALWAYS, activator, null, null, TO_CHAR);
      block;
   }
   else if (command(CMD_STEAL) or command(CMD_FILCH) or
command(CMD_PICK_POCKET))
   {
   act ("You grasp but notice your body is not solid enough to steal.",
	  A_ALWAYS, activator, null, null, TO_CHAR);
      block;
   }
   goto start;
}
dilend

/* The guild stuff is the only part which interacts with nanny! If a guild
   is chosen, then set self.guild to the chosen one, and nanny will
   take care of the rest when the DIL programs are complete */

#define FIGHTER_BIT  1
#define HEALER_BIT   2
#define CONJURER_BIT 4
#define THIEF_BIT    8

dilbegin nanny_guild( arg : string );
var
   exdp   : extraptr;
   state  : integer;
   s      : string;
   s2     : string;
   picks  : integer;
code
{
   exdp  := "$nanny" in self.extra;
   state := atoi(exdp.descr);

   picks := FIGHTER_BIT + CONJURER_BIT + HEALER_BIT + THIEF_BIT;

   if (self.alignment < 350)
     unset(picks, HEALER_BIT);

   if (self.race == RACE_DWARF)
     unset(picks, CONJURER_BIT);
   else if (self.race == RACE_BROWNIE)
     unset(picks, FIGHTER_BIT);
   else if (self.race == RACE_GROLL)
   {
      unset(picks, THIEF_BIT);
      unset(picks, HEALER_BIT);
      unset(picks, CONJURER_BIT);
   }
   else if ((self.race == RACE_HALF_ORC) or
	    (self.race == RACE_HALF_OGRE))
   {
      unset(picks, HEALER_BIT);
      unset(picks, CONJURER_BIT);
   }

   if (state == 0)
   {
      s := "&nChoose your guild:&n";

      if (isset(picks, FIGHTER_BIT))
	s := s + "  &c+w1&cw) "+GUILD_UDG_FIGHTER+"&n";

      if (isset(picks, THIEF_BIT))
	s := s + "  &c+w2&cw) "+GUILD_UDG_THIEF+"&n";

      if (isset(picks, HEALER_BIT))
	s := s + "  &c+w3&cw) "+GUILD_UDG_CLERIC+"&n";

      if (isset(picks, CONJURER_BIT))
	s := s + "  &c+w4&cw) "+GUILD_UDG_MAGE+"&n";

      s := s + "Please select a guild or Help: ";

      sendtext(s, self);

      exdp.descr := "1";
      return;
   }

   s := getword(arg);

   if ((s == "1") and isset(picks, FIGHTER_BIT))
   {
      sendtext("You are now a member of the "+
	       GUILD_UDG_FIGHTER+" Guild.&n", self);
      self.guild := GUILD_UDG_FIGHTER;
   }
   else if ((s == "2") and isset(picks, THIEF_BIT))
   {
      sendtext("You are now a member of the "+
	       GUILD_UDG_THIEF + " Guild.&n", self);
      self.guild := GUILD_UDG_THIEF;
   }
   else if ((s == "3") and isset(picks, HEALER_BIT))
   {
      sendtext("You are now a member of the "+
	       GUILD_UDG_CLERIC + " Guild.&n", self);
      self.guild := GUILD_UDG_CLERIC;
   }
   else if ((s == "4") and isset(picks, CONJURER_BIT))
   {
      sendtext("You are now a member of the "+
	       GUILD_UDG_MAGE + " Guild.&n", self);
      self.guild := GUILD_UDG_MAGE;
   }
   else
   {
      sendtext("No such guild available to you.&nPlease select one of the
guild numbers (1 - 4) or Help: ", self);
      return;
   }

   subextra(self.extra, "$nanny");
   return;
}
dilend



dilbegin nanny_alignment( arg : string );
var
   exdp   : extraptr;
   state  : integer;
   s      : string;
   cat    : integer;
code
{
   exdp  := "$nanny" in self.extra;
   state := atoi(exdp.descr);

   if ((self.race == RACE_HALFLING) or (self.race == RACE_ELF) or
       (self.race == RACE_HALF_ELF) or (self.race == RACE_BROWNIE))
     cat := 1; /* Good and Neutral */

   else if ((self.race == RACE_GROLL) or (self.race == RACE_HALF_ORC) or
	    (self.race == RACE_HALF_OGRE))
     cat := 2; /* Evil or Neutral */
   else if (self.race == RACE_DARK_ELF)
   {
      self.alignment := -1000;
      goto done;
   }
   else
     cat := 3; /* Player's choice */

   if (state == 0)
   {
      if (cat == 1)
	sendtext("&nPlease choose your personality:&n"+
		 "  &c+w1&cw) A saint             (Good).&n"+
		 "  &c+w2&cw) Who cares?          (Neutral)&n"+
		 "Please select 1, 2 or Help: ", self);
      else if (cat == 2)
	sendtext("&nPlease choose your personality:&n"+
		 "  &c+w2&cw) Who cares?          (Neutral)&n"+
		 "  &c+w3&cw) The devil's brother (Evil)&n"+
		 "Please select 1, 2, 3 or Help: ", self);
      else
	sendtext("&nPlease choose your personality:&n"+
		 "  &c+w1&cw) A saint             (Good).&n"+
		 "  &c+w2&cw) Who cares?          (Neutral)&n"+
		 "  &c+w3&cw) The devil's brother (Evil)&n"+
		 "Please select 1, 2, 3 or Help: ", self);

      exdp.descr := "1";
      return;
   }

   s := getword(arg);

   if ((s == "1") and (cat != 2))
   {
      sendtext("You are now a saint.&n", self);
      self.alignment := 850;
   }
   else if (s == "2")
   {
      sendtext("Who cares about it anyway?&n", self);
      self.alignment := 0;
   }
   else if ((s == "3") and (cat != 1))
   {
      sendtext("So be it...&n", self);
      self.alignment := -850;
   }
   else
   {
      if (cat == 1)
	sendtext("No such personality, please select 1, 2 "+
		 "or Help: ", self);
      else if (cat == 2)
	sendtext("No such personality, please select 2, 3 "+
		 "or Help: ", self);
      else
	sendtext("No such personality, please select 1, 2, 3 "+
		 "or Help: ", self);
      return;
   }

   :done:
   substring(exdp.names, "personality");
   addstring(exdp.names, "login guilds");
   exdp.descr := "0";
   return;
}
dilend


dilbegin nanny_race( arg : string );
var
   exdp   : extraptr;
   state  : integer;
   s      : string;
code
{
   exdp  := "$nanny" in self.extra;
   state := atoi(exdp.descr);

   if (state == 0)
   {
      sendtext("&nPlease choose your race:&n"+
	       "  &c+w1&cw) Human&cw            &c+w 7&cw) Dark-Elf (hard)&n"+
	       "  &c+w2&cw) Dwarf&cw	      &c+w 8&cw) Brownie&n"+
	       "  &c+w3&cw) Halfling&cw	      &c+w 9&cw) Groll&n"+
	       "  &c+w4&cw) Gnome&cw	      &c+w10&cw) Half-Orc&n"+
	       "  &c+w5&cw) Elf&cw	      &c+w11&cw) Half-Ogre&n"+
	       "  &c+w6&cw) Half-elf&n"+
	       "Please select 1 - 11 or Help: ", self);

      exdp.descr := "1";
      return;
   }

   s := getword(arg);

   if (s == "1")
   {
      sendtext("You are now a human.&n", self);
      self.race := RACE_HUMAN;
   }
   else if (s == "2")
   {
      sendtext("You are now a dwarf.&n", self);
      self.race := RACE_DWARF;
   }
   else if (s == "3")
   {
      sendtext("You are now a halfling.&n", self);
      self.race := RACE_HALFLING;
   }
   else if (s == "4")
   {
      sendtext("You are now a gnome.&n", self);
      self.race := RACE_GNOME;
   }
   else if (s == "5")
   {
      sendtext("You are now an elf.&n", self);
      self.race := RACE_ELF;
   }
   else if (s == "6")
   {
      sendtext("You are now a half-elf.&n", self);
      self.race := RACE_HALF_ELF;
   }
   else if (s == "7")
   {
      sendtext("You are now a dark-elf.&n", self);
      self.race := RACE_DARK_ELF;
   }
   else if (s == "8")
   {
      sendtext("You are now a Brownie.&n", self);
      self.race := RACE_BROWNIE;
   }
   else if (s == "9")
   {
      sendtext("You are now a Groll.&n", self);
      self.race := RACE_GROLL;
   }
   else if (s == "10")
   {
      sendtext("You are now a half-orc.&n", self);
      self.race := RACE_HALF_ORC;
   }
   else if (s == "11")
   {
      sendtext("You are now a half-ogre.&n", self);
      self.race := RACE_HALF_OGRE;
   }
   else
   {
      sendtext("Please choose 1 - 11 or Help: ", self);
      return;
   }

   substring(exdp.names, "login races");
   addstring(exdp.names, "personality");
   exdp.descr := "0";
   return;
}
dilend


dilbegin nanny_sex( arg : string );
var
   exdp   : extraptr;
   state  : integer;
   s      : string;
code
{
   exdp  := "$nanny" in self.extra;
   state := atoi(exdp.descr);

   if (state == 0)
   {
      sendtext("&nPlease choose your gender:&n"+
	  "  &c+w1&cw) Male&n"+
	  "  &c+w2&cw) Female&n"+
	  "Please select 1, 2 or Help: ", self);
      exdp.descr := "1";
      return;
   }

   s := getword(arg);

   if (s == "1")
   {
      sendtext("You are now a male.&n", self);
      self.sex := SEX_MALE;
   }
   else if (s == "2")
   {
      sendtext("You are now a female.&n", self);
      self.sex := SEX_FEMALE;
   }
   else
   {
      sendtext("Please choose 1, 2 or Help: ", self);
      return;
   }

   substring(exdp.names, "genders");
   addstring(exdp.names, "login races");
   exdp.descr := "0";
   return;
}
dilend


dilbegin nanny_maiden( arg : string );
var
   exdp   : extraptr;
   texdp  : extraptr;
   state  : integer;
   s      : string;
code
{
   exdp  := "$nanny" in self.extra;
   state := atoi(exdp.descr);

   if (state == 0)
   {
      sendtext("&nPlease enter your mother's maiden name (Help): ", self);
      exdp.descr := "1";
   }
   else if (state == 1)
   {
      texdp := "$maiden" in self.info;
      if (not texdp)
      {
	 addextra(self.info, {"$maiden"}, arg);
	 texdp := "$maiden" in self.info;
      }
      sendtext("&nIs '&c+w"+texdp.descr+"&cw' correct (Y/N/H)? ", self);
      exdp.descr := "2";
   }
   else if (state == 2)
   {
      s := " " + getword(arg);

      if (" y" in s)
      {
	 substring(exdp.names, "maiden name");
	 addstring(exdp.names, "personal email");
	 exdp.descr := "0";
      }
      else if (" n" in s)
      {
	 subextra(self.info, "$maiden");
	 exdp.descr := "0";
	 nanny_maiden("");
      }
      else
	sendtext("&nPlease anwser Yes or No : ", self);
   }
   return;
}
dilend


dilbegin nanny_email( arg : string );
var
   exdp   : extraptr;
   texdp  : extraptr;
   state  : integer;
   s      : string;
code
{
   exdp  := "$nanny" in self.extra;
   state := atoi(exdp.descr);

   if (state == 0)
   {
      sendtext("&nYou have the option of supplying your email now: ", self);
      exdp.descr := "1";
   }
   else if (state == 1)
   {
      texdp := "$email" in self.info;
      if (not texdp)
      {
	 addextra(self.info, {"$email"}, arg);
	 texdp := "$email" in self.info;
      }
      sendtext("&nIs '&c+w"+texdp.descr+"&cw' correct (Y/N/H)? ", self);
      exdp.descr := "2";
   }
   else if (state == 2)
   {
      s := " " + getword(arg);

      if (" y" in s)
      {
	 :done:
	 substring(exdp.names, "personal email");
	 addstring(exdp.names, "genders");
	 exdp.descr := "0";
      }
      else if (" n" in s)
      {
	 subextra(self.info, "$email");
	 exdp.descr := "0";
	 nanny_email("");
      }
      else
	sendtext("&nPlease anwser Yes or No : ", self);
   }
   return;
}
dilend

/* Special notice: When "help" is chosen by the user, the "$nanny" extra
   description's description field is subtracted one, effectively putting
   the user at the state just before help was requested. */

dilbegin nanny( arg : string );
external
   nanny_maiden( arg : string );
   nanny_email( arg : string );
   nanny_sex( arg : string );
   nanny_race( arg : string );
   nanny_guild( arg : string );
   nanny_alignment( arg : string );

var
   exdp   : extraptr;

code
{
   exdp := "$nanny" in self.extra;
   if (not exdp)
   {
      addextra(self.extra, {"$nanny", "maiden name"}, "0");
      exdp := "$nanny" in self.extra;
   }


   if ("maiden name" in exdp.names)
     nanny_maiden( arg );

   if ("personal email" in exdp.names)
     nanny_email( arg );

   if ("genders" in exdp.names)
     nanny_sex( arg );

   if ("login races" in exdp.names)
     nanny_race( arg );

   if ("personality" in exdp.names)
     nanny_alignment( arg );

   if ("login guilds" in exdp.names)
     nanny_guild( arg );

   quit;
}
dilend



dilbegin playerinit();
code
{
   exec("pray odin", self);
   exec("wear all", self);
   exec("claim dictionary", self);

   if (self.race==RACE_HUMAN)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_HP ] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_BRA] := 4;
      self.abilities[ABIL_CHA] := 4;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_MAG] := 4;
   }
   else if (self.race==RACE_DWARF)
   {
      self.abilities[ABIL_STR] := 6;
      self.abilities[ABIL_CON] := 2;
      self.abilities[ABIL_HP ] := 6;
      self.abilities[ABIL_DEX] := 2;
      self.abilities[ABIL_BRA] := 4;
      self.abilities[ABIL_CHA] := 2;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_MAG] := 2;
   }
   else if (self.race==RACE_ELF)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_HP ] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_BRA] := 4;
      self.abilities[ABIL_CHA] := 6;
      self.abilities[ABIL_DIV] := 6;
      self.abilities[ABIL_MAG] := 4;
   }
   else if (self.race==RACE_HALFLING)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_CON] := 6;
      self.abilities[ABIL_HP ] := 4;
      self.abilities[ABIL_DEX] := 6;
      self.abilities[ABIL_BRA] := 4;
      self.abilities[ABIL_CHA] := 2;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_MAG] := 2;
   }
   else if (self.race==RACE_GNOME)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_HP ] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_BRA] := 6;
      self.abilities[ABIL_CHA] := 4;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_MAG] := 4;
   }
   else if (self.race==RACE_HALF_OGRE)
   {
      self.abilities[ABIL_STR] := 6;
      self.abilities[ABIL_CON] := 6;
      self.abilities[ABIL_HP ] := 6;
      self.abilities[ABIL_DEX] := 2;
      self.abilities[ABIL_BRA] := 2;
      self.abilities[ABIL_CHA] := 2;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_MAG] := 2;
   }
   else if (self.race==RACE_HALF_ORC)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_HP ] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_BRA] := 2;
      self.abilities[ABIL_CHA] := 2;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_MAG] := 2;
   }
   else if (self.race==RACE_BROWNIE)
   {
      self.abilities[ABIL_STR] := 2;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_HP ] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_BRA] := 6;
      self.abilities[ABIL_CHA] := 4;
      self.abilities[ABIL_DIV] := 2;
      self.abilities[ABIL_MAG] := 6;
   }
   else if (self.race==RACE_HALF_ELF)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_MAG] := 4;
      self.abilities[ABIL_DIV] := 4;
      self.abilities[ABIL_CHA] := 4;
      self.abilities[ABIL_BRA] := 4;
      self.abilities[ABIL_HP ] := 4;
   }
   else if (self.race==RACE_GROLL)
   {
      self.abilities[ABIL_STR] := 6;
      self.abilities[ABIL_DEX] := 2;
      self.abilities[ABIL_CON] := 8;
      self.abilities[ABIL_MAG] := 2;
      self.abilities[ABIL_DIV] := 2;
      self.abilities[ABIL_CHA] := 2;
      self.abilities[ABIL_BRA] := 2;
      self.abilities[ABIL_HP ] := 8;
   }
   else if (self.race==RACE_DARK_ELF)
   {
      self.abilities[ABIL_STR] := 4;
      self.abilities[ABIL_DEX] := 4;
      self.abilities[ABIL_CON] := 4;
      self.abilities[ABIL_MAG] := 6;
      self.abilities[ABIL_DIV] := 2;
      self.abilities[ABIL_CHA] := 4;
      self.abilities[ABIL_BRA] := 6;
      self.abilities[ABIL_HP ] := 4;
   }

   if (self.guild == GUILD_UDG_FIGHTER)
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]+2;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+0;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]+2;
      self.abilities[ABIL_HP] :=self.abilities[ABIL_HP]+2;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]-2;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]-2;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]+0;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]-2;

      self.weapons[WPN_AXE_HAM] :=  5;
      self.weapons[WPN_UNARMED] :=  5;
      self.weapons[WPN_SWORD]   :=  5;

      self.weapons[WPN_FIST]        :=  5;
      self.weapons[WPN_BATTLE_AXE]  :=  5;
      self.weapons[WPN_LONG_SWORD]  :=  5;
      self.weapons[WPN_BROAD_SWORD] :=  5;

      exec("alias kd kill deer", self);
      exec("alias kb kill badger", self);
      exec("alias kf kill fox", self);
      exec("alias kr kill rabbit", self);
      exec("alias ks kill skunk", self);
   }
   else if (self.guild == GUILD_UDG_THIEF)
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]+0;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+4;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]+0;
      self.abilities[ABIL_HP] :=self.abilities[ABIL_HP]+0;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]-2;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]-0;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]+0;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]-2;

      self.skills[SKI_SHIELD] := 5;
      self.skills[SKI_SEARCH] := 5;
      self.skills[SKI_HIDE]   := 5;
      self.skills[SKI_SNEAK]  := 5;

      self.weapons[WPN_FIST]         :=  5;
      self.weapons[WPN_UNARMED]      :=  5;
      self.weapons[WPN_SWORD]        :=  5;
      self.weapons[WPN_SHORT_SWORD]  :=  5;
      self.weapons[WPN_DAGGER]       :=  5;

      exec("alias kd kill deer", self);
      exec("alias kb kill badger", self);
      exec("alias kf kill fox", self);
      exec("alias kr kill rabbit", self);
      exec("alias ks kill skunk", self);
   }
   else if (self.guild == GUILD_UDG_CLERIC)
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]+0;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+0;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]+0;
      self.abilities[ABIL_HP] :=self.abilities[ABIL_HP]+0;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]+2;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]-2;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]+2;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]+0;

      self.weapons[WPN_CLUB_MACE]     :=  5;
      self.weapons[WPN_MACE]          :=  5;

      self.spells[SPL_DIVINE]         :=  5;
      self.spells[SPL_MIND]           :=  5;

      self.spells[SPL_CURE_WOUNDS_1]  :=  5;
      self.spells[SPL_CAUSE_WOUNDS_1] :=  5;

      self.skills[SKI_FIRST_AID]      :=  5;

      exec("alias cu cast cure light wounds &&", self);
      exec("alias ca cast cause light wounds &&", self);
      exec("alias kk kill &&; ca &&", self);

      exec("alias kd kk deer", self);
      exec("alias kb kk badger", self);
      exec("alias kf kk fox", self);
      exec("alias kr kk rabbit", self);
      exec("alias ks kk skunk", self);
   }
   else if (self.guild == GUILD_UDG_MAGE)
   {
      self.abilities[ABIL_STR] :=self.abilities[ABIL_STR]-2;
      self.abilities[ABIL_DEX] :=self.abilities[ABIL_DEX]+2;
      self.abilities[ABIL_CON] :=self.abilities[ABIL_CON]-2;
      self.abilities[ABIL_HP] :=self.abilities[ABIL_HP]-2;
      self.abilities[ABIL_MAG] :=self.abilities[ABIL_MAG]+2;
      self.abilities[ABIL_DIV] :=self.abilities[ABIL_DIV]-2;
      self.abilities[ABIL_CHA] :=self.abilities[ABIL_CHA]+2;
      self.abilities[ABIL_BRA] :=self.abilities[ABIL_BRA]+2;

      self.weapons[WPN_SWORD]         :=  5;
      self.weapons[WPN_DAGGER]        :=  5;

      self.skills[SKI_SCROLL_USE]    :=  5;
      self.skills[SKI_WAND_USE]      :=  5;

      self.spells[SPL_DETECTION]     :=  5;
      self.spells[SPL_DET_INVISIBLE] :=  5;

      self.spells[SPL_DETECTION]     :=  5;
      self.spells[SPL_DET_MAGIC]     :=  5;

      self.spells[SPL_SUMMONING]     :=  5;
      self.spells[SPL_ENERGY_BOLT]   :=  5;

      exec("alias eb cast energy bolt &&", self);
      exec("alias kk kill &&; eb &&", self);

      exec("alias kd kk deer", self);
      exec("alias kb kk badger", self);
      exec("alias kf kk fox", self);
      exec("alias kr kk rabbit", self);
      exec("alias ks kk skunk", self);
   }

   self.hometown := "temple@udgaard";

   self.skills[SKI_FLEE]        := 50;
   self.skills[SKI_CONSIDER]    := 50;
   self.skills[SKI_DIAGNOSTICS] := 50;

   if (self.outside != findroom(self.hometown))
   {
      act("$1n is taken away to start a new life.",
	  A_HIDEINV, self, null, null, TO_ROOM);
      link(self, findroom(self.hometown));
      act("$1n appears from thin air.", A_HIDEINV, self, null, null, TO_ROOM);
   }

   act("&h", A_ALWAYS, self, null, null, TO_CHAR);
   exec("look", self);

   act("&c+rYou are a guest here until you save yourself.&cw",
       A_ALWAYS, self, null, null, TO_CHAR);
   quit;
}
dilend


dilbegin provoked_attack(victim : unitptr, ch : unitptr);
code
{
   if (not (victim.type & (UNIT_ST_NPC|UNIT_ST_PC)))
     return; /* FALSE */

   if (not (ch.type & (UNIT_ST_PC|UNIT_ST_NPC)))
     return; /* FALSE */

   if (victim.level >= 200)
     return; /* FALSE */

   if (ch.level >= 200)
     return; /* FALSE */

   if (not isset(ch.charflags, CHAR_SELF_DEFENCE))
   {
      if ((ch.fighting == null) and
	  (not isset(victim.charflags, CHAR_LEGAL_TARGET)))
        set(victim.charflags, CHAR_SELF_DEFENCE);
   }

   /* Test for LEGAL_TARGET bit */
   if (isset(victim.charflags, CHAR_PROTECTED))
   {
       if ((not isset(victim.charflags, CHAR_LEGAL_TARGET)) and
           (not isset(ch.charflags, CHAR_SELF_DEFENCE)))
         set(ch.charflags, CHAR_LEGAL_TARGET);
   }

   if (victim.position <= POSITION_SLEEPING)
     return; /* FALSE */

   if (isset(victim.charflags, CHAR_PEACEFUL))
     return; /* FALSE */

   if (opponent(victim, ch))
     return; /* TRUE */

   set_fighting(victim, ch);

   return; /* TRUE */
}
dilend

/* Copy of function from limits.c */
dilbegin integer hit_limit(i : integer);
code
{
   return (i * 3);
}
dilend


/* You can add any number of hitpoints, even negative. Excess are chopped
   off to max_hp, negative may kill because of the position_update */

dilbegin add_hitpoints(ch : unitptr, php : integer);
code
{
   ch.hp := ch.hp + php;
   if (ch.hp > ch.max_hp)
     ch.hp := ch.max_hp;
   position_update(ch);
   return;
}
dilend

dilbegin integer may_tele_away(u : unitptr);
code
{
   while (u)
   {
      if (u.flags & UNIT_FL_NO_TELEPORT)
        return(FALSE);
      u := u.outside;
   }

   return(TRUE);
}
dilend

dilbegin integer skill_duration(hm : integer);
code
{
   if (hm < 20)
     return (2);
   else if (hm > 150)
     return (15);
   else
     return (hm / 10);
}
dilend

dilbegin unitptr unit_room(u : unitptr);
code
{
   while (u.type != UNIT_ST_ROOM)
     u := u.outside;

   return(u);
}
dilend


dilbegin unitptr unit_char(u : unitptr);
code
{
   while ((u.type & (UNIT_ST_NPC | UNIT_ST_PC)) == 0)
     u := u.outside;

   return(u);
}
dilend


/* Important SPELL messages that should be intercepted by the various
   spells are:

     spl_dispel       <power> (caused by a dispel magic)
     spl_awaken       <power> (caused by an awakening spell)

     spl_cure_blind   <power>
     spl_cure_disease <power>

*/



/*
========================================================================= */
/*                       SPELL UTILITY FUNCTIONS
 */
/*
 */
/* Mainly copied onto spell targets to affect them (e.g. sleep).
 */
/*
========================================================================= */


dilbegin simulate_spell(arg : string);
var
   t : unitptr;
   p : integer;
   s : string;

code
{
   t := findunit(self, arg, FIND_UNIT_SURRO|FIND_UNIT_WORLD, null);

   if (not t)
   {
      act("No such target to fire spell on.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   p := atoi(getword(arg));

   s := getword(arg);

   act("You fire the spell '"+s+"' on $2n with power "+itoa(p)+
	" and argument '"+arg+"'.",
       A_ALWAYS, self, t, null, TO_CHAR);

   s (self, t, arg, p);

   quit;
}
dilend



/* Send message: "spl_awaken <power>" to remove a sleep spell.    */
/* Power is checkked against the power of the sleep spell         */

dilbegin aware recall spl_sleep(pwr : integer);
var
   i : integer;
   j : integer;
   parse : stringlist;

code
{
   interrupt(SFB_MSG, TRUE, check);
   interrupt(SFB_DEAD, activator == self, stop);

   heartbeat := PULSE_SEC * 30;
   j := 1 + pwr / 10;

   while (i < j)
   {
      if (self.position > POSITION_SLEEPING)
        exec("sleep", self);
      else
        exec("snore", self);

      :loop:
      wait(SFB_TICK | SFB_CMD, TRUE);

      if (command(CMD_AUTO_TICK))
      {
	 i := i + 1;
      }
      else
      {
	 if (command(CMD_WAKE) and (activator == self))
	 {
	    block;
	    act("You dream about waking up.",
		A_ALWAYS, self, null, null, TO_CHAR);
	 }

	 goto loop;
      }
   }

   :check:
   parse := getwords(argument);
   if ((parse.[0] == "spl_awaken") or (parse.[0] == "spl_dispel"))
   {
      if (atoi(parse.[1]) >= pwr)
	goto the_end;
   }
   goto loop;

   :the_end:
   act("You feel less sleepy.", A_ALWAYS, self, null, null, TO_CHAR);
   :stop:
   if (self.type ==UNIT_ST_NPC)
    {
    exec ("wake",self);
    exec ("stand",self);
    }
   quit;
}
dilend


dilbegin aware recall spl_poison(pwr : integer);
var
   i : integer;
   j : integer;
   parse : stringlist;

code
{
   interrupt(SFB_DEAD, activator == self, stop);
   interrupt(SFB_MSG, TRUE, check);

   heartbeat := PULSE_POINTS / 2;
   j := 1 + pwr / 10;

   while (i < j)
   {
      :loop:
      wait(SFB_TICK, TRUE);

      i := i + 1;

      self.hp := self.hp - j;
      self.mana := self.mana - 2*j;
      self.endurance := self.endurance - 2*j;

      if (self.hp < -10)
      {
	 act("$1n dies from the powerful poison in $1s blood.",
             A_HIDEINV, self, null, null, TO_ROOM);
         act("You die from the powerful poison burning in your veins.",
	     A_HIDEINV, self, null, null, TO_CHAR);
	 position_update(self);
	 goto the_end;
      }

      act("$1n looks very ill.", A_HIDEINV, self, null, null, TO_ROOM);
      act("You feel poison burning in your veins.",
	  A_HIDEINV, self, null, null, TO_CHAR);

      position_update(self);
   }

   :check:
   parse := getwords(argument);
   if ((parse.[0] == "spl_rem_poison") or (parse.[0] == "spl_dispel"))
   {
      if (atoi(parse.[1]) >= pwr)
	goto the_end;
   }
   goto loop;


   :the_end:
   act("The burning in your veins ends.",
       A_ALWAYS, self, null, null, TO_CHAR);
   :stop:
   quit;
}
dilend


dilbegin aware recall spl_plague(pwr : integer);
external
   integer skillresist@basis(aa : integer, ad : integer,
                             sa : integer, sd : integer);
var
  state : integer;
  i     : integer;
  j     : integer;
  u     : unitptr;
  parse : stringlist;
code
{
   interrupt(SFB_MSG, TRUE, check);
   interrupt(SFB_DEAD, activator == self, stop);

   heartbeat := PULSE_SEC * 60 * 3;

   :loop:
   if (state >= 24)
     goto the_end;
   wait(SFB_TICK, TRUE);

   state := state + 1;
   i := state + 5;
   if (i > 10) i := 10;

   on rnd(1, i) goto
     case1, case2, case3, case4, case5,
     case6, case7, case8, case9, case10;

   :case1:
   :case2:
   :case3:
   act("You feel sick.",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n look very pale.",
       A_HIDEINV,self,null,null,TO_ROOM);
   if (self.type == UNIT_ST_PC)
   {
      if (self.full > 0)
	self.full := 0;
      if (self.thirst > 0)
	self.thirst := 0;
   }
   goto loop;

   :case4:
   :case5:
   :case6:
   :case7:
   :case8:
   act("You feel painfull cramps run through your body.",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("$1n lies down in cramps.",
       A_HIDEINV,self,null,null,TO_ROOM);

   if (self.endurance > 0)
     self.endurance := 0;

   self.hp := self.hp - 2;
   act("$1n contracts in painful cramps.",
       A_ALWAYS, self, null, null, TO_ROOM);
   position_update(self);
   exec("rest", self);
   goto loop;


   :case9:
   :case10:
   /* Only contaminates when coughing blood (9-10) */
   act("A painfull series of coughs causes you to cough up blood.",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n cougs up blood - some hits you.",
       A_HIDEINV,self,null,null,TO_ROOM);

   u := findrndunit(self, FIND_UNIT_SURRO, UNIT_ST_PC|UNIT_ST_NPC);

   if (dilfind("spl_plague@basis", u))
     goto loop;

   j := skillresist(pwr, u.abilities[ABIL_CON], pwr, u.abilities[ABIL_CHA]);

   if (j < 0)
     goto loop;

   dilcopy("spl_plague@basis("+itoa((3*pwr)/5)+")", u);

   self.hp := self.hp - self.max_hp / 5;
   position_update(self);
   goto loop;


   :check:
   parse := getwords(argument);
   if ((parse.[0] == "spl_rem_disease") or (parse.[0] == "spl_dispel"))
   {
      if (atoi(parse.[1]) >= pwr)
	goto the_end;
   }
   goto loop;


   :the_end:
   act("You feel much better.", A_ALWAYS, self, null, null, TO_CHAR);
   :stop:
   quit;
}
dilend



dilbegin aware recall spl_madness(pwr : integer);
var
   i : integer;
   j : integer;
   degree : integer;
   parse : stringlist;
   u : unitptr;
code
{
   interrupt(SFB_DEAD, activator == self, stop);
   interrupt(SFB_MSG, TRUE, check);

   heartbeat := PULSE_POINTS;
   j := 1 + pwr / 10;

   :loop:
   if (i >= 64)
     goto the_end;

   wait(SFB_TICK, TRUE);

   i := i + 1;

   if (self.position < POSITION_SLEEPING)
     goto loop;

   if (self.position == POSITION_SLEEPING)
   {
      act("You have horrible nightmares.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      act("$1n mumbles in $1s sleep.",
	  A_SOMEONE, self, null, null, TO_ROOM);
      goto loop;
   }

   degree := 32 - i / 2;

   act("The mad look in $1n's eyes intensifies",
       A_HIDEINV, self, null, null,TO_ROOM);

   on rnd(degree, degree + 10) goto
     case0, case1, case2, case3, case4, case5, case6, case7, case8,
     case9, case10, case11, case12, case13, case14, case15, case16,
     case17, case18, case19, case20, case21, case22, case23, case24,
     case25, case26, case27, case28, case29, case30, case31, case32,
     case33, case34, case35, case36, case37, case38, case39, case40,
     case41, case42;

   :case0:
   :case1:
   :case2:
   u := findrndunit(self, FIND_UNIT_SURRO, UNIT_ST_NPC|UNIT_ST_PC);

   if (visible(self, u))
   {
      act("You sudden realise that $2n has betrayed you.",
	  A_SOMEONE, self, u, null, TO_CHAR);
      act("$1n screams 'You evil thing of betrayal' "+
	  "and growls at $2n.", A_SOMEONE, self, u, null, TO_ROOM);
      exec("kill "+u.name, self);
   }
   goto loop;

   :case3:
   act("You are burdened by the weight of your money.",
       A_ALWAYS, self, null, null, TO_CHAR);
   exec("drop money", self);
   goto loop;

   :case4:
   if (findunit(self, "corpse", FIND_UNIT_HERE, null))
   {
      act("You see a CORPSE! RUN AWAY!",
	  A_ALWAYS, self, null, null, TO_CHAR);
      act("$1n screams 'A CORPSE! A CORPSE!'",
	  A_HIDEINV, self, null, null, TO_ROOM);
      exec("n", self);
      exec("e", self);
      exec("s", self);
      exec("w", self);
      exec("u", self);
      exec("d", self);
      exec("puke", self);
   }
   goto loop;

   :case5:
   act("Certainly, you need no earthly goods...",
       A_ALWAYS, self,null,null,TO_CHAR);
   exec("remove all", self);
   exec("drop all", self);
   goto loop;

   :case6:
   act("You feel inspired, so you decide to write a poem!",
       A_ALWAYS, self, null, null, TO_CHAR);
   exec("sit", self);

   u := findunit(self, "letter", FIND_UNIT_HERE, null);
   if (not u)
     u := findunit(self, "paper", FIND_UNIT_HERE, null);

   if (u and (u.type == UNIT_ST_OBJ))
   {
      if (self.name in self.extra)
      {
	 act("You despair, as you see, the other text written "+
	     " on the page.", A_ALWAYS, self, null, null, TO_CHAR);
	 act("You spit at the page.", A_ALWAYS, self, null, null, TO_CHAR);
	 act("$1n looks desperate and spits at $2n.",
	     A_HIDEINV, self,u,null,TO_ROOM);
      }
      else
      {
	 act("You despair, as you can't remember anything.",
	     A_ALWAYS, self, null, null, TO_CHAR);
	 act("$1n looks desperately at a $2n.",
	     A_HIDEINV, self,u,null,TO_ROOM);
      }
      exec("drop letter", self);
   }
   else
   {
      act("You despair, as you can't find any paper.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      act("$1n looks desperate.",
	  A_HIDEINV, self,u,null,TO_ROOM);
      exec("cry", self);
   }
   goto loop;

   :case7:
   :case8:
   :case20:
   :case21:
   :case9:
   act("You sing 'Hare Khrisna Hare Khrisna Hare "+
       "Rama Hare Hare Hare Hare Hare'.",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("$1n sing 'Hare Khrisna Hare Khrisna Hare "+
       "Rama Hare Hare Hare Hare Hare'.",
       A_HIDEINV, self, null, null, TO_ROOM);
   goto loop;

   :case10:
   :case11:
   if (findunit(self, "guard", FIND_UNIT_HERE, null))
   {
      act("You love guards... they look so masculine!",
	  A_ALWAYS, self, null, null, TO_CHAR);
      exec("french guard", self);
   }
   else
   {
      act("You miss the company of your friends, the guards.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      exec("sniff", self);
   }
   goto loop;

   :case12:
   act("You decide that you need no equipment.",
       A_ALWAYS, self, null, null, TO_CHAR);
   exec("remove all", self);
   goto loop;

   :case13:
   :case14:
   act("You feel generous, and leave some gold for the poor.",
       A_ALWAYS, self, null, null, TO_CHAR);
   exec("drop 10 gold", self);
   goto loop;

   :case15:
   :case16:
   :case17:
   act("You are almost driven insane by the "+
       "humming tone you keep hearing.",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("$1n puts $1s fingers in $1s ears and looks tormented.",
       A_HIDEINV,self,null,null,TO_ROOM);
   goto loop;

   :case18:
   :case19:
   act("You suddenly feel sick.",
       A_ALWAYS, self, null, null, TO_CHAR);
   exec("puke", self);
   goto loop;

   :case22:
   act("There is no room! You have to get out! NOW!",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n gets a claustrofobic look in $1s eyes.",
       A_HIDEINV,self,null,null,TO_ROOM);
   exec("flee", self);
   goto loop;

   :case23:
   act("You hear a voice commanding you north.",
       A_ALWAYS, self, null, null, TO_CHAR);
   exec("n", self);
   goto loop;

   :case24:
   act("You are urged to go south from here.",
       A_ALWAYS, self, null, null, TO_CHAR);
   exec("s", self);
   goto loop;

   :case25:
   act("You are urged to go east from here.",
       A_ALWAYS, self, null, null, TO_CHAR);
   exec("e", self);
   goto loop;

   :case26:
   act("You are urged to go west from here.",
       A_ALWAYS, self, null, null, TO_CHAR);
   exec("w", self);
   goto loop;

   :case27:
   exec("scream", self);
   goto loop;

   :case28:
   :case29:
   :case30:
   :case31:
   :case32:
   act("$1n mumbles something to $1mself.",
       A_HIDEINV,self,null,null,TO_ROOM);
   act("You talk to all the voices you hear.",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto loop;

   :case33:
   act("Nobody likes you any more...",
       A_ALWAYS, self, null, null, TO_CHAR);
   exec("cry", self);
   goto loop;

   :case34:
   act("Someone is following you around!",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n looks paraniodly at everyone.",
       A_HIDEINV,self,null,null,TO_ROOM);
   goto loop;

   :case35:
   :case36:
   act("This is funny...",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n laughs like he heard something extremely funny.",
       A_SOMEONE,self,null,null,TO_ROOM);
   goto loop;

   :case37:
   :case38:
   :case39:
   act("This seems like a great spot to sit down.",
       A_ALWAYS, self, null, null, TO_CHAR);
   exec("sit", self);
   goto loop;

   :case40:
   :case41:
   :case42:
   act("You feel so happy.",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n smiles madly.",
       A_HIDEINV,self,null,null,TO_ROOM);
   goto loop;


   :check:
   parse := getwords(argument);
   if ((parse.[0] == "spl_rem_disease") or (parse.[0] == "spl_dispel"))
   {
      if (atoi(parse.[1]) >= pwr)
	goto the_end;
   }
   goto loop;


   :the_end:
   act("The battle with your own mind is over.",
       A_ALWAYS, self, null, null, TO_CHAR);
   :stop:
   quit;
}
dilend



/* Used to determine if a summoner has summoned more than one creature */

dilbegin aware sum_check();
var
   fol : unitptr;
code
{
   heartbeat := PULSE_SEC*3;
   while(self.master==null)
   {
      pause;
   }
   interrupt(SFB_MSG,(argument=="piss_off") and (activator!=self),byebye);
   heartbeat := PULSE_SEC * 10;

   :loop:

   fol := self.outside.inside;
   while(fol!=null)
   {
      if (dilfind("sum_check@basis",fol))
	if ((fol!=self) and (fol.master==self.master))
	  sendto("piss_off",fol);
      fol := fol.next;
   }
   pause;
   goto loop;

   :byebye:
   exec("emote howls in pain as it loses his link to the real world.",self);
   exec("emote vanishes in a cloud of grey dust.",self);
   destroy(self);
   quit;
}
dilend


dilbegin recall magic_summoned(pwr : integer);
var
  d : integer;
  parse : stringlist;

code
{
   interrupt(SFB_DEAD, activator == self, vanish);

   heartbeat := PULSE_SEC * 10;
   d := pwr / 20 + 2;

   while (d > 0)
   {
      :loop:
      wait(SFB_TICK | SFB_MSG, TRUE);

      if (command(CMD_AUTO_TICK))
      {
         d := d - 1;
      }
      else
      {
	 parse := getwords(argument);
	 if (parse.[0] == "spl_dispel")
	 {
	    if (atoi(parse.[1]) >= pwr)
	      goto loop;
	 }
      }
   }

   :vanish:
   act("$1n vanishes in a puff of smoke.",
       A_SOMEONE, self, null, null, TO_ROOM);

   destroy(self);
}
dilend


/* Assists the 'master' which has summoned it! */
dilbegin master_servant();
var
  d : integer;
  parse : stringlist;

code
{
   heartbeat := PULSE_VIOLENCE;

   :loop:
   wait(SFB_COM, activator == self.master);

   if (self.master.fighting == null)
     goto loop;

   if (self.fighting == null)
   {
      exec("hit " + self.master.fighting.name, self);
   }

   pause;

   while (self.master.hp <= self.master.max_hp / 3)
   {
      exec("rescue " + self.master.name, self);
      pause;
   }
   goto loop;
}
dilend


dilbegin recall base_recall(dest : string, pwr : integer,t_recall:integer);
external integer may_tele_away(u : unitptr);
var
  u : unitptr;
  i : integer;
code
{
   interrupt(SFB_DEAD, activator == self, stop);
   interrupt(SFB_MSG,  (getword(argument) == "spl_dispel") and
                       (atoi(getword(argument)) > pwr), stop);

   heartbeat := PULSE_SEC * 10;

   act("Tiny blue sparks spring from $1n's head.",
       A_ALWAYS,self,null,null,TO_ROOM);
   act("There is a static feeling in the air.",
       A_ALWAYS,self,null,null,TO_CHAR);
   pause;
if (t_recall==0)
   act("The air begins to feel rather strange.",
       A_ALWAYS,self,null,null,TO_ROOM);
   act("The magical buildup slowly increases.",
       A_ALWAYS,self,null,null,TO_CHAR);
   pause;
if (t_recall==0)
   act("The air feels thick with magic and there are strange, "+
       "flickering lights.",
       A_ALWAYS,self,null,null,TO_ROOM);
   act("The air around you is charged with magic.",
       A_ALWAYS,self,null,null,TO_CHAR);
   pause;

   u := findsymbolic(dest);
   if (not u)
   {
      u := findsymbolic(self.hometown);
      if (not u)
      {
	 u := findsymbolic("temple@udgaard");
	 if (not u)
	   goto stop;
      }
   }

   i := may_tele_away@basis(self);
   if (not i)
     goto stop;

   act("$1n disappears in a cloud of blue sparks.",
       A_ALWAYS,self,null,null,TO_ROOM);

   act("You are transferred home.",
       A_ALWAYS,self,null,null,TO_CHAR);

   link(self, u);
   act("$1n appears in a cloud of blue sparks.",
       A_ALWAYS,self,null,null,TO_ROOM);

   exec("look", self);

   quit;

   :stop:
   act("The magic feeling fades away.",
       A_ALWAYS,self,null,null,TO_CHAR);
   quit;
}
dilend



dilbegin integer skillresist(aa : integer, ad : integer,
			     sa : integer, sd : integer);
code
{
   return (openroll(100, 5) + aa + sa - ad - sd - 50);
}
dilend


dilbegin aware undead_exec();
var
   cancast : integer;
code
{
   cancast := dilfind("combat_mag@function", self);

   :loop:
   wait(SFB_CMD, activator == self);

   /* This is what the undeads cant do... */
   if (command(CMD_SNEAK) or command(CMD_HIDE) or
       command(CMD_STEAL) or command(CMD_RECITE) or command(CMD_USE) or
       command (CMD_SHOUT) or command (CMD_TELL) or command (CMD_PICK) or
       command (CMD_FILCH) or command (CMD_PICK_POCKET) or
       command(CMD_AID) or command(CMD_TRIP))
   {
      block;
      exec("moan", self);
   }
   else if ((command(CMD_CAST)) and (cancast!=1))
   {
      block;
      exec("moan", self);
   }
   goto loop;
}
dilend


dilbegin undead_obey(i : integer);
code
{
   interrupt(SFB_MSG, TRUE, test);
   on_activation(self.master == null, stop);
   priority;

   :loop:
   wait(SFB_DONE, command(CMD_TELL));

   if (activator != self.master)
     goto loop;

   if (target != self)
     goto loop;

   if (not visible(self, self.master))
     goto loop;

   exec(argument, self);
   goto loop;

   :test:
   if (getword(argument) == "spl_dispel")
     if (atoi(getword(argument)) >= i)
       goto stop;
   goto loop;

   :stop:
   i := dildestroy("undead_exec@basis", self);
   exec("follow", self);
   quit;
}
dilend


dilbegin string sizestring(cm : integer);
var
   ftn : integer;
   fts : string;
   inn : integer;
   ins : string;
code
{
   /* One inch equals 2,54 cm. There are 12 inches (30.48 cm) to a foot */
   ftn := cm / 30;
   inn := (10*(cm % 30))/25;
   if (ftn == 1)
     fts := "one foot";
   else if (ftn > 1)
     fts := itoa(ftn)+" feet";
   else
     fts := "";

   if (inn == 1)
     ins := "one inch";
   else if (inn > 1)
     ins := itoa(inn)+" inches";
   else
     ins := "";

   if (fts != "")
   {
      if (ins != "")
        fts := fts + " and ";
   }
   else
   {
      if (inn < 1)
	ins := "less than an inch";
   }

   return (fts + ins);
}
dilend


dilbegin string weightstring(p : integer);
var
   s : string;
code
{
   if (p == 1)
     s := "one pound";
   else if (p > 1)
     s := itoa(p)+" pounds";
   else
     s := "less than a pound";

   return (s);
}
dilend



/*
========================================================================= */
/*                               THE SKILLS
 */
/*
 */
/* The skills themselves. These routines are copied onto the user
 */
/* when a skill is used.
 */
/*
========================================================================= */


dilbegin diagnose(arg : string);
external
   string sizestring(cm : integer);
   string weightstring(cm : integer);
   integer skillresist@basis(aa : integer, ad : integer,
			     sa : integer, sd : integer);

var
   percent : integer;
   hm      : integer;
   s1      : string;
   s2      : string;
   vict    : unitptr;
   skilla  : integer;
code
{
   if ((self.type == UNIT_ST_PC) and
       (self.skills[SKI_DIAGNOSTICS] == 0))
   {
      act("You must practice first.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "")
   {
      vict := self.fighting;
      if (vict == null)
      {
	 act("Diagnose who?",
             A_ALWAYS, self, null, null, TO_CHAR);
	 quit;
      }
   }
   else
   {
      vict := findunit(self, arg, FIND_UNIT_SURRO, null);
      if (vict == null)
      {
	 act("Nobody here by that name.",
	     A_ALWAYS, self, null, vict, TO_CHAR);
	 quit;
      }
   }

   if (not (vict.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("It seems to be dead?",
	  A_ALWAYS, self, null, null, TO_CHAR);
      return;
   }

   if (vict.max_hp > 0)
     percent := (100 * vict.hp) / vict.max_hp;
   else
     percent := -1; /* How could MAX_HIT be < 1?? */

   if (self.type == UNIT_ST_PC)
     skilla := self.skills[SKI_DIAGNOSTICS];
   else
     skilla := self.abilities[ABIL_BRA];

   hm := skillresist(self.abilities[ABIL_BRA], 20,
				skilla, 50);

   if (hm > 0)
     hm := 0;

   percent := percent + ((percent * (-hm))/100);

   if (percent >= 100)
     act("$3n is in an excellent condition.",
	 A_ALWAYS, self, null, vict, TO_CHAR);
   else if (percent >= 90)
     act("$3n has a few scratches.",
	 A_ALWAYS, self, null, vict, TO_CHAR);
   else if (percent >= 75)
     act("$3n has some small wounds and bruises.",
         A_ALWAYS, self, null, vict, TO_CHAR);
   else if (percent >= 50)
     act("$3n has quite a few wounds.",
         A_ALWAYS, self, null, vict, TO_CHAR);
   else if (percent >= 30)
     act("$3n has some big nasty wounds and scratches.",
         A_ALWAYS, self, null, vict, TO_CHAR);
   else if (percent >= 15)
     act("$3n looks pretty hurt.",
         A_ALWAYS, self, null, vict, TO_CHAR);
   else if (percent >= 0)
     act("$3n is in an awful condition.",
	 A_ALWAYS, self, null, vict, TO_CHAR);
   else
     act("$3n is bleeding awfully from big wounds.",
	 A_ALWAYS, self, null, vict, TO_CHAR);

   if (self.fighting == null)
   {
      s1 := weightstring@basis(vict.baseweight);
      s2 := sizestring@basis(vict.height);
      act("$3e weighs "+s1+" and is "+s2+" tall.",
	  A_SOMEONE, self, null, vict, TO_CHAR);
   }

   quit;
}
dilend



dilbegin ditch(arg : string);
var
   u : unitptr;
   s : string;
code
{
   if (arg == "")
   {
      act("They are not here.",
          A_SOMEONE, self, null, null,TO_CHAR);
      quit;
   }

   u := findunit(self, arg, FIND_UNIT_WORLD, null);
   secure(u,losthim);

   if (u == null)
   {
      act("No such person by that name!.",
       A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if ((u.master == self) and  (u.type == UNIT_ST_NPC))
   {
      act("$1n tries to ditch $3n but fails miserably.",
	  A_SOMEONE, self, null, u, TO_NOTVICT);
      act("you can not ditched $3n.",
	  A_SOMEONE, self,null,u, TO_CHAR);
      quit;
   }
   if ((u.master == self) and  (u.type == UNIT_ST_PC))
   {
      act("$1n has ditched $3n.",
	  A_SOMEONE, self, null, u, TO_NOTVICT);
      act("$1n has ditched you.",
	  A_SOMEONE,self, null,u, TO_VICT);
      act("you have ditched $3n.",
	  A_SOMEONE, self,null,u, TO_CHAR);
      exec("follow self",u);
      quit;
   }
   else
   {
      act("$2n is not following you",
	  A_SOMEONE, self, u, null, TO_CHAR);
      quit;
   }

   :losthim:
   quit;
}
dilend

dilbegin assist(arg : string);
var
   u : unitptr;
   s : string;
code
{
if(arg=="") {
  act("Assist who??",A_SOMEONE,self,null,null,TO_CHAR);
  quit; }
u:=findunit(self,arg,FIND_UNIT_SURRO,null);
secure(u,losthim);
if(u==null) {
  act("No such person by that name!.",A_SOMEONE,self,null,null,TO_CHAR);
  quit; }
if(u==self) {
  act("Assist yourself?  Your in pretty bad shape if your the only one who
can help you.",A_SOMEONE,self,null,null,TO_CHAR);
  quit; }
if(self.fighting) {
  act("No way! You are too busy fighting for your life!",
      A_ALWAYS,self,null,null,TO_CHAR);
  quit; }
if(u.fighting==null) {
  act("Assist $3n? $3e isn't fighting anything.",
      A_SOMEONE,self,null,u,TO_CHAR);
  quit; }
if((self.type==UNIT_ST_PC) and (u.fighting.type==UNIT_ST_PC)) {
  if(not(isset(u.fighting.pcflags,PC_PK_RELAXED))) {
    act("You cannot do this until $3n has signed the book of blood.",
        A_SOMEONE,self,null,u.fighting,TO_CHAR);
    quit; }
  if(not(isset(self.pcflags,PC_PK_RELAXED))) {
    act("You are not allowed to do this until you sign the book of blood.",
        A_ALWAYS,self,null,u.fighting,TO_CHAR);
    quit; } }
act("You bravely come to $3n's assistance.",
A_SOMEONE,self,null,u,TO_CHAR);
act("$1n bravely comes to your assistance.",
A_SOMEONE,self,null,u,TO_VICT);
act("$1n bravely comes to $3n's assistance.",
A_SOMEONE,self,null,u,TO_NOTVICT);
set_fighting(self,u.fighting);

:losthim:
quit;
}
dilend


dilbegin donate(arg:string);
var
d_rooms:stringlist;
room_idx:string;
room    :       unitptr;
item    :       unitptr;
num     :       integer;
i:integer;
here:unitptr;
code
{
:start:
d_rooms:={"udonate@midgaard","mdonate@midgaard","ndonate@nymgaard"};
room_idx:=self.outside.nameidx+"@"+self.outside.zoneidx;
if (room_idx in d_rooms)
  {
  act("You may not donate while in a donations room!",
    A_ALWAYS, self, null, null, TO_CHAR);
    quit;
  }

item := findunit(self, arg, FIND_UNIT_INVEN, null);
if (not(item.type == UNIT_ST_OBJ))
  {
  act("You do not have anything like that in your inventory.",
    A_ALWAYS, self, null, null, TO_CHAR);
    quit;
  }
  if ("midgaard" in arg)
  room := findroom("mdonate@midgaard");
  else if ("nymgaard" in arg)
  room := findroom("ndonate@nymgaard");
else
  room := findroom("udonate@udgaard");

num := rnd(1, 200);
if (num > 195)
  {
  if (item.cost >= 75000)
    {
    experience(+75, self);
    act("You are rewarded 75 experience for your act.",
      A_ALWAYS, self, null, null, TO_CHAR);
    }else if (item.cost >= 50000)
      {
      experience(+35, self);
      act("You are rewarded 35 experience for your act.",
        A_ALWAYS, self, null, null, TO_CHAR);
      }
    }

i:=0;
here:=room.inside;
while ((here!=null) and (i<5))
  {
  if (here.idx==item.idx)i:=i+1;
  here:=here.next;
  }

  act("You donate $2n to those in need.",
    A_ALWAYS, self, item, null, TO_CHAR);
  act("$1n donates $2n to those in need.",
    A_SOMEONE, self, item, null, TO_REST);

  if (i<5)
    {
  item.cost := 0;
  link(item, room);
  act("A Glowing red portal appears hovering in the air, $2n"+
    " emerges from it and drops to the floor.",
    A_ALWAYS, room.inside, item, null, TO_ALL);
    }
    else
     destroy (item);
  quit;
}
dilend



dilbegin evaluate(arg : string);

external
   string sizestring(cm : integer);
   string weightstring(cm : integer);

var
   u : unitptr;
   s : string;
   degrade : integer;
code
{
   if (arg == "")
   {
      act("What do you wish to evaluate?",
	  A_SOMEONE, self, null, null,TO_CHAR);
      quit;
   }

   u := findunit(self, arg, FIND_UNIT_HERE, null);

   if (u == null)
   {
      act("No such thing by that name!", A_SOMEONE, self, null, null,
TO_CHAR);
      quit;
   }

   if (u.type != UNIT_ST_OBJ)
   {
      act("You can't evaluate $3m.",
	  A_SOMEONE, self, null, u, TO_CHAR);
      quit;
   }

   s := weightstring@basis(u.weight);
   act("The $3N weighs "+s+".",
       A_SOMEONE, self, null, u, TO_CHAR);

   if ((u.manipulate & (MANIPULATE_WEAR_FINGER | MANIPULATE_WEAR_NECK  |
			MANIPULATE_WEAR_BODY   | MANIPULATE_WEAR_HEAD  |
			MANIPULATE_WEAR_LEGS   | MANIPULATE_WEAR_FEET  |
			MANIPULATE_WEAR_HANDS  | MANIPULATE_WEAR_ARMS  |
			MANIPULATE_WEAR_SHIELD | MANIPULATE_WEAR_ABOUT |
			MANIPULATE_WEAR_WAIST  | MANIPULATE_WEAR_WRIST |
			MANIPULATE_WIELD       | MANIPULATE_WEAR_EAR   |
			MANIPULATE_WEAR_BACK   | MANIPULATE_WEAR_CHEST |
			MANIPULATE_WEAR_ANKLE)) or
       (u.objecttype == ITEM_WEAPON))
   {
      s := sizestring@basis(u.height);
      act("$3e has been made to fit a person of "+s+".",
	  A_SOMEONE, self, null, u, TO_CHAR);
   }

   if (u.hp > 0)
   {
      degrade := (100*u.hp) / u.max_hp;

      if (degrade >= 90)
	s := "in an excellent condition.";
      else if (degrade >= 75)
	s := "in a good condition.";
      else if (degrade >= 50)
	s := "worn.";
      else if (degrade >= 30)
	s := "in a poor condition";
      else if (degrade >= 10)
	s := "in a horrible condition.";
      else
	s := "nearly broken.";
   }
   else if (u.hp == -1)
     s := "in an excellent condition.";
   else
     s := "broken.";

   act("The $3N appears to be "+s,
       A_ALWAYS, self, null, u, TO_CHAR);

   if (u.objecttype == ITEM_ARMOR)
     on u.value[0] goto clothes,leather,leather,metal,metal;
   else if (u.objecttype == ITEM_SHIELD)
     goto metal;
   else if (u.objecttype == ITEM_WEAPON)
     goto metal;
   else if (u.objecttype == ITEM_WORN)
     goto clothes;
   else
   {
      if ((u.manipulate & (MANIPULATE_WEAR_FINGER | MANIPULATE_WEAR_NECK  |
			     MANIPULATE_WEAR_BODY   | MANIPULATE_WEAR_HEAD  |
			     MANIPULATE_WEAR_LEGS   | MANIPULATE_WEAR_FEET  |
			     MANIPULATE_WEAR_HANDS  | MANIPULATE_WEAR_ARMS  |
			     MANIPULATE_WEAR_SHIELD | MANIPULATE_WEAR_ABOUT |
			     MANIPULATE_WEAR_WAIST  | MANIPULATE_WEAR_WRIST |
			     MANIPULATE_WIELD       | MANIPULATE_WEAR_EAR   |
			     MANIPULATE_WEAR_BACK   | MANIPULATE_WEAR_CHEST |
			     MANIPULATE_WEAR_ANKLE)) == 0)
      {
         goto nextstep;
      }
      goto metal; /* What else can one do? */
   }
   goto nextstep;

   :clothes:
   act ("Refitting the size of it, requires tailoring skills.",
        A_ALWAYS,self,null, null,TO_CHAR);
   goto nextstep;

   :leather:
   act ("Refitting the size of it, requires leahter working skills.",
        A_ALWAYS,self,null, null,TO_CHAR);
   goto nextstep;

   :metal:
   act ("Refitting the size of it, requires metal skills.",
        A_ALWAYS,self,null, null,TO_CHAR);
   goto nextstep;

   :nextstep:

   /* Eventually add

      Material Lore
      Appraisal
      Spell Lore
    */

   quit;
}
dilend


dilbegin resize(arg:string);
external
   res_clothes@basis (tgt:unitptr,tgt_pc:unitptr);
   res_lth@basis (tgt:unitptr,tgt_pc:unitptr);
   res_metal@basis (tgt:unitptr,tgt_pc:unitptr);
var
   item : unitptr;
   tgt_pc : unitptr;
code
{
   if (arg == "")
   {
      act("What do you wish to resize?", A_SOMEONE, self, null, null,TO_CHAR);
      quit;
   }

   item := findunit(self, arg, FIND_UNIT_INVEN, null);

   if (item == null)
   {
      act("No such thing by that name!", A_SOMEONE, self, null, null,
TO_CHAR);
      quit;
   }

   tgt_pc := findunit(self,arg,FIND_UNIT_SURRO,null);

   if (tgt_pc==null)
     tgt_pc := self;

   if (not (item.type&UNIT_ST_OBJ))
   {
      act("You can't resize that!", A_SOMEONE, self, null, null,
	  TO_CHAR);
      quit;
   }

   if (item.objecttype == ITEM_ARMOR)
   {
      if ((item.value[0]<ARM_CLOTHES)or
          (item.value[0]>ARM_PLATE))
      {
         act ("The armor seems to be broken.",
	      A_ALWAYS,self,null, null,TO_CHAR);
         quit;
      }
      on item.value[0] goto clothes,leather,leather,metal,metal;
   }
   else if (item.objecttype == ITEM_SHIELD)
     goto metal;
   else if (item.objecttype == ITEM_WEAPON)
     goto metal;
   else if (item.objecttype == ITEM_WORN)
     goto clothes;
   else
   {
      if ((item.manipulate & (MANIPULATE_WEAR_FINGER | MANIPULATE_WEAR_NECK  |
			     MANIPULATE_WEAR_BODY   | MANIPULATE_WEAR_HEAD  |
			     MANIPULATE_WEAR_LEGS   | MANIPULATE_WEAR_FEET  |
			     MANIPULATE_WEAR_HANDS  | MANIPULATE_WEAR_ARMS  |
			     MANIPULATE_WEAR_SHIELD | MANIPULATE_WEAR_ABOUT |
			     MANIPULATE_WEAR_WAIST  | MANIPULATE_WEAR_WRIST |
			     MANIPULATE_WIELD       | MANIPULATE_WEAR_EAR   |
			     MANIPULATE_WEAR_BACK   | MANIPULATE_WEAR_CHEST |
			     MANIPULATE_WEAR_ANKLE)) == 0)
      {
         act ("There is no way the $3N can be resized.",
	      A_SOMEONE, self, null, item, TO_CHAR);
         quit;
      }
      goto metal; /* What else can one do? */
   }
   quit;

   :clothes:
   res_clothes(item,tgt_pc);
   quit;
   :leather:
   res_lth (item,tgt_pc);
   quit;
   :metal:
   res_metal(item,tgt_pc);
   quit;
}
dilend


dilbegin res_clothes(tgt:unitptr,tgt_pc:unitptr);
external
   integer skillresist@basis(aa : integer, ad : integer,
			     sa : integer, sd : integer);
   unitptr unit_room@basis(u:unitptr);
var
  hm:integer;
  amount:integer;
  size:string;
  diff:integer;
  skilla : integer;
  rm:unitptr;
  skilld : integer;
  hold_eq:unitptr;
  wield_eq:unitptr;

code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_RESIZE_CLOTHES] <= 0))
   {
      act("You have no knowledge in tailoring, you must practice first.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

/*
   rm := unit_room(self);
   if ("$clothes room" in rm.extra)
     goto workshop;

   hold_eq := equipment (self ,WEAR_HOLD);
   wield_eq := equipment (self,WEAR_WIELD);
   if ((not("$refit clothes" in hold_eq.extra)) and
       (not("$refit clothes" in wield_eq.extra)))
   {
      act ("You need to hold or use a proper tailoring tool to work on $2n.",
	   A_ALWAYS,self,tgt,null,TO_CHAR);
      quit;
   }
*/
   :workshop:
   if ("$resized" in tgt.extra)
   {
      act("You see that the $2N has already been resized, you are unable "+
          "to do more yourself.",
	   A_ALWAYS,self,tgt,null,TO_CHAR);
      quit;
   }

   if (self.type == UNIT_ST_PC)
     skilla := self.skills[SKI_RESIZE_CLOTHES];
   else
     skilla := self.abilities[ABIL_DEX];

   skilld := 2*tgt.value[1] + 6*tgt.value[2];

   hm := skillresist(self.abilities[ABIL_DEX],
		     tgt.spells[SPL_CREATION],
		     skilla, skilld);

   if (hm<=-100)
     goto major_fail;
   if (hm<-50)
     goto fail;
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   amount := (100*tgt_pc.height) / tgt.height;
   if (amount > 100)
     diff := amount - 100;
   else
     diff := 100 - amount;
   if (self.endurance<diff) goto fail_endurance;

   if (tgt_pc.height>tgt.height)
    size:="enlarges"
   else
    size:="shrinks";

   tgt.max_hp := tgt.max_hp-diff;
   tgt.hp := tgt.hp-diff;
   tgt.height := tgt_pc.height;

   addextra(tgt.extra, {"$resized"}, "");

   if (tgt_pc==self)
   {
      act("You skillfully work on $2n till it $3t enough to fit.",
	  A_ALWAYS, self, tgt, size, TO_CHAR);
      act("$1n skillfully works on $2n till it $3t enough to fit $1m",
	  A_SOMEONE, self, tgt, size, TO_REST);
   }
   else
   {
      act("You skillfully work on $2n till it $3t enough to fit "+
	  tgt_pc.name+".", A_SOMEONE, self, tgt, size, TO_CHAR);
      act("$1n skillfully works on "+tgt.title+
	  " till it $3t enough to fit $2n",
	  A_SOMEONE, self, tgt_pc, size, TO_REST);
   }
   quit;

   :fail:
   tgt.hp := tgt.hp-diff;
   if (tgt.hp<1) goto major_fail;
   act("You try to $3t $2n but you make a mistake and damage it instead",
       A_ALWAYS, self, tgt, size, TO_CHAR);
   act ("$1n tries to $3t but $1e makes a mistake and damages it instead.",
	A_SOMEONE, self, tgt, size, TO_REST);
   quit;

   :major_fail:
   act("You try to $3t $2n but the job is to much for you and you destroy
it.",
       A_ALWAYS, self, tgt, size, TO_CHAR);
   act ("$1n tries to $3t but the job is to much for $1m and he destroys it.",
	A_SOMEONE, self, tgt, size, TO_REST);
  addextra (tgt.extra,tgt.names,"Well whatever this was it looks like
someone realy screwed up resizing this.");
  tgt.title:=tgt.title+"Broken";
   tgt.objecttype := ITEM_TRASH;

   quit;

   :fail_endurance:
   act("You begin to work on $2n but relize you are much to tired to finish.",
       A_ALWAYS, self, tgt,null, TO_CHAR);
   act("$1n Begins working on $2n but relizes $1e is to tired and slumps "+
       "back exausted.",
       A_SOMEONE, self, tgt, size, TO_REST);
   quit;
}
dilend

dilbegin res_lth(tgt:unitptr,tgt_pc:unitptr);
external
   integer skillresist@basis(aa : integer, ad : integer,
			     sa : integer, sd : integer);
   unitptr unit_room@basis(u:unitptr);
var
  hm:integer;
  amount:integer;
  size:string;
  diff:integer;
  rm:unitptr;
  skilla : integer;
  skilld : integer;
  hold_eq:unitptr;
  wield_eq:unitptr;

code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_RESIZE_LEATHER] <= 0))
   {
      act("You have no knowledge in leather, you must practice first.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

/*
   rm := unit_room(self);
   if ("$leather room" in rm.extra) goto workshop;

   hold_eq := equipment (self ,WEAR_HOLD);
   wield_eq := equipment (self,WEAR_WIELD);

   if ((not("$refit leather" in hold_eq.extra)) and
       (not("$refit leather" in wield_eq.extra)))
   {
      act ("You need to use a proper leather tool to work on $2n.",
	   A_ALWAYS,self,tgt,null,TO_CHAR);
      quit;
   }
*/
   :workshop:
   if ("$resized" in tgt.extra)
   {
      act("You see that the $2N have already been resized, you are unable "+
          "to do more yourself.",
	   A_ALWAYS,self,tgt,null,TO_CHAR);
      quit;
   }

   if (self.type == UNIT_ST_PC)
     skilla  :=  self.skills[SKI_RESIZE_LEATHER];
   else
     skilla  :=  self.abilities[ABIL_STR];

   skilld := 2*tgt.value[1] + 6*tgt.value[2];

   hm := skillresist(self.abilities[ABIL_DEX],
		     tgt.spells[SPL_CREATION],
		     skilla, skilld);

   if (hm<=-100)goto major_fail;

   if (hm<-50) goto fail;

   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   amount := (100*tgt_pc.height) / tgt.height;
   if (amount > 100)
     diff := amount - 100;
   else
     diff := 100 - amount;
   if (self.endurance<diff) goto fail_endurance;

   if (tgt_pc.height>tgt.height)
     size := "enlarges"
   else
     size := "shrinks";


   tgt.max_hp := tgt.max_hp-diff;
   tgt.hp := tgt.hp-diff;
   tgt.height := tgt_pc.height;

   addextra(tgt.extra, {"$resized"}, "");

   if (tgt_pc==self)
   {
      act("You skillfully work on $2n till it $3t enough to fit.",
	  A_ALWAYS, self, tgt, size, TO_CHAR);
      act("$1n skillfully works on $2n till it $3t enough to fit $1m",
	  A_SOMEONE, self, tgt, size, TO_REST);
   }
   else
   {
      act("You skillfully work on $2n till it $3t enough to fit
"+tgt_pc.name+".",
	  A_SOMEONE, self, tgt, size, TO_CHAR);
      act("$1n skillfully works on "+tgt.title+" till it $3t enough to fit
$2n",
	  A_SOMEONE, self, tgt_pc, size, TO_REST);
   }

   quit;
   :fail:
   tgt.hp := tgt.hp-diff;
   if (tgt.hp<1) goto major_fail;
   act("You try to $3t $2n but you make a mistake and damage it instead",
       A_ALWAYS, self, tgt, size, TO_CHAR);
   act ("$1n tries to $3t but $1e makes a mistake and damages it instead.",
	A_SOMEONE, self, tgt, size, TO_REST);
   quit;

   :major_fail:

   act("You try to $3t $2n but the job is to much for you and you destroy
it.",
       A_ALWAYS, self, tgt, size, TO_CHAR);
   act ("$1n tries to $3t but the job is to much for $1m and he destroys it.",
	A_SOMEONE, self, tgt, size, TO_REST);
  addextra (tgt.extra,tgt.names,"Well whatever this was it looks like
someone realy screwed up resizing this.");
  tgt.title:=tgt.title+"Broken";
   tgt.objecttype := ITEM_TRASH;

   quit;

   :fail_endurance:
   act("You begin to work on $2n but relize you are much to tired to finish.",
       A_ALWAYS, self, tgt,null, TO_CHAR);
   act ("$1n Begins working on $2n but relizes $1e is to tired and slumps
back exausted.",
	A_SOMEONE, self, tgt, size, TO_REST);
   quit;

}
dilend

dilbegin res_metal(tgt:unitptr,tgt_pc:unitptr);
external
   integer skillresist@basis(aa : integer, ad : integer,
			     sa : integer, sd : integer);
   unitptr unit_room@basis(u:unitptr);

var
  hm:integer;
  amount:integer;
  size:string;
  diff:integer;
  rm:unitptr;
  skilla : integer;
  skilld : integer;
  hold_eq:unitptr;
  wield_eq:unitptr;

code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_RESIZE_METAL] <= 0))
   {
      act("You have no knowledge in smithing, you must practice first.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

/*
   rm := unit_room(self);
   if ("$metal room" in rm.extra) goto workshop;

   hold_eq := equipment (self ,WEAR_HOLD);
   wield_eq := equipment (self,WEAR_WIELD);

   if ((not("$refit metal" in hold_eq.extra)) and
       (not("$refit metal" in wield_eq.extra)))
   {
      act ("You need to use a proper smithing tool to work on $2n.",
	   A_ALWAYS,self,tgt,null,TO_CHAR);
      quit;
   }
*/
   :workshop:
   if ("$resized" in tgt.extra)
   {
      act("You see that the $2N have already been resized, you are unable "+
          "to do more yourself.",
	   A_ALWAYS,self,tgt,null,TO_CHAR);
      quit;
   }

   if (self.type == UNIT_ST_PC)
     skilla  :=  self.skills[SKI_RESIZE_METAL];
   else
     skilla := self.abilities[ABIL_STR];

   skilld := 2*tgt.value[1] + 6*tgt.value[2];

   hm := skillresist(self.abilities[ABIL_STR],
		     tgt.spells[SPL_CREATION],
		     skilla, skilld);

   if (hm<=-100)goto major_fail;
   if (hm<-50) goto fail;
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   amount := (100*tgt_pc.height) / tgt.height;
   if (amount > 100)
     diff := amount - 100;
   else
     diff := 100 - amount;
   if (self.endurance<diff) goto fail_endurance;

   if (tgt_pc.height>tgt.height)
    size:="enlarges"
   else
     size := "shrinks";


   tgt.max_hp := tgt.max_hp-diff;
   tgt.hp := tgt.hp-diff;
   tgt.height := tgt_pc.height;

   addextra(tgt.extra, {"$resized"}, "");

   if (tgt_pc==self)
   {
      act("You skillfully work on $2n till it $3t enough to fit.",
	  A_ALWAYS, self, tgt, size, TO_CHAR);
      act("$1n skillfully works on $2n till it $3t enough to fit $1m",
	  A_SOMEONE, self, tgt, size, TO_REST);
   }
   else
   {
      act("You skillfully work on $2n till it $3t enough to fit "+
	  tgt_pc.name+".", A_SOMEONE, self, tgt, size, TO_CHAR);
      act("$1n skillfully works on "+tgt.title+
	  " till it $3t enough to fit $2n",
	  A_SOMEONE, self, tgt_pc, size, TO_REST);
   }

   quit;
   :fail:
   tgt.hp := tgt.hp-diff;
   if (tgt.hp<1) goto major_fail;
   act("You try to $3t $2n but you make a mistake and damage it instead",
       A_ALWAYS, self, tgt, size, TO_CHAR);
   act ("$1n tries to $3t but $1e makes a mistake and damages it instead.",
	A_SOMEONE, self, tgt, size, TO_REST);
   quit;

   :major_fail:

   act("You try to $3t $2n but the job is to much for you and you destroy
it.",
       A_ALWAYS, self, tgt, size, TO_CHAR);
   act ("$1n tries to $3t but the job is to much for $1m and he destroys it.",
	A_SOMEONE, self, tgt, size, TO_REST);
  addextra (tgt.extra,tgt.names,"Well whatever this was it looks like
someone realy screwed up resizing this.");
  tgt.title:=tgt.title+"Broken";
   tgt.objecttype := ITEM_TRASH;

   quit;

   :fail_endurance:
   act("You begin to work on $2n but relize you are much to tired to finish.",
       A_ALWAYS, self, tgt,null, TO_CHAR);
   act ("$1n Begins working on $2n but relizes $1e is to tired and slumps
back exausted.",
	A_SOMEONE, self, tgt, size, TO_REST);
   quit;

}
dilend

/* The cuff skill.

   The skill is implemented on the hand cuffs themselves.

*/

dilbegin cuff(arg : string);
code
{
   act("You seem to be missing a pair of hand cuffs.",
       A_ALWAYS, self, null, null, TO_CHAR);
   quit;
}
dilend



/* The climb skill as a special routine to be connected to ROOMS

  Ticks  : None
  Used on: ROOMS
  Syntax : climb(destination:string, difficulty:integer,
	         damage : integer, direction : integer);
  Example: dilcopy climb@function("deck@ship", 17, 20, CMD_UP);

     This special dil is used for the climb skill and should be set
     on stationary objects (stationary mast, robe, tree, wall, etc).
     The <difficulty> is the skill-amount required to climb. A skill of 100
     would be a 50% chance for the expert thief / climber.
     The <damage> is how much damage is given if you fail to climb the
     object. When you fail, you "fall" to the <destination>, so you can
     make gravity work correctly.
     The destination can be the same room in which you started.
     The <direction> is the direction in which a climb is required
     (most usually it is up, which is macro UP == 5).
*/

dilbegin climb(destination:string, difficulty:integer,
               damage:integer, direction:integer);
external
   integer skillresist@basis(aa : integer, ad : integer,
                             sa : integer, sd : integer);
var
   dest : unitptr;
   skilla : integer;
   hm : integer;
   doorname : string;
code
{
   if (not self.exit_to[direction])
   {
      log("No such exit in climb dil.");
      quit;
   }

   if (not findroom(destination))
   {
      log("No such room in climb dil.");
      quit;
   }

   doorname := self.exit_names[direction].[0];
   /* One could check for an empty name here... */

   :loop:
   wait(SFB_CMD, command(CMD_CLIMB) or command(direction));

   if (self.type == UNIT_ST_PC)
   {
      skilla := self.skills[SKI_CLIMB];
      if (skilla < 1)
	skilla := -25;
   }
   else
     skilla := self.abilities[ABIL_DEX];

   hm := skillresist(skilla, 0,
		     activator.abilities[ABIL_DEX], 0);

   if (hm >= difficulty)
   {
      act("You easily climb the $2t.",
	  A_ALWAYS, activator, doorname, null, TO_CHAR);
      act("$1n easily climbs the $2t.",
	  A_HIDEINV, activator, doorname, null, TO_ROOM);
      goto loop;
   }

   dest := findroom(destination);

   if (dest != activator.outside)
   {
      act("You fall and hit yourself!",
	  A_ALWAYS, activator, doorname, null, TO_CHAR);

      act("$1n failed to climb the $2t and takes a nasty fall...",
	  A_SOMEONE, activator, doorname, null, TO_ROOM);

      link(activator, dest);

      act("$1n failed to climb the $2t and lands at your feet...",
	  A_SOMEONE, activator, doorname, null, TO_ROOM);
   }
   else
   {
      act("You fail to climb the $2t!",
	  A_ALWAYS, activator, doorname, null, TO_CHAR);

      act("$1n failed to climb the $2t!",
	  A_SOMEONE, activator, doorname, null, TO_ROOM);
   }

   if (activator.level < IMMORTAL_LEVEL)
   {
      activator.hp := activator.hp - damage;
      position_update(activator);
   }
   block;
   goto loop;
}
dilend





dilbegin kick(arg : string);

external
   provoked_attack@basis(victim : unitptr, ch : unitptr);

var
   bonus : integer;
   targ  : unitptr;

code
{
   if ((self.type == UNIT_ST_PC) and (self.weapons[WPN_KICK] <= 0))
   {
      act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "")
   {
      if (self.fighting)
      {
	 targ := self.fighting;
	 goto kick;
      }

      act("Kick who?", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   targ := findunit(self, arg, FIND_UNIT_SURRO, null);

   if (targ == null)
   {
      act("That person is not here!", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if (not (targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("You can't kick that, silly!", A_SOMEONE, self, null, null,
	  TO_CHAR);
      quit;
   }

   if (targ == self)
   {
      act("You kick yourself.", A_HIDEINV, self, null, null,
	  TO_CHAR);
      act("$1n kicks $1mself.", A_HIDEINV, self, null, null,
	  TO_ROOM);
      quit;
   }

   if ((targ.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC))
  {
if (not(isset (self.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless you sign the book of blood.",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (not(isset (targ.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless $2e signs the book of blood.",
  A_ALWAYS,self,targ,null,TO_CHAR);
  quit;
  }
  }


   :kick:
   /* Penalty for wielding a weapon while kicking! */
   if (equipment(self, WEAR_WIELD))
     bonus := -25;
   else
     bonus := +25;
   if ((self.endurance -2) <= 0)
     act("You are too exhausted to attempt that.", A_ALWAYS, self, null,
         null, TO_CHAR);
   else self.endurance := (self.endurance - 2);
   provoked_attack@basis(targ, self);
   bonus := meleeattack(self, targ, bonus, WPN_KICK);
   quit;
}
dilend


dilbegin trip(arg : string);

external
   integer skillresist@basis(aa : integer, ad : integer,
                             sa : integer, sd : integer);
   provoked_attack@basis(victim : unitptr, ch : unitptr);

var
   skilla : integer;
   skilld : integer;
   hm     : integer;
   targ   : unitptr;

code
{
   if ((self.type == UNIT_ST_PC) and (self.skills[SKI_TRIP] <= 0))
   {
      act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "")
   {
      if (self.fighting)
      {
	 targ := self.fighting;
	 goto trip;
      }
      else
      {
	 act("Who do you wish to trip?", A_SOMEONE, self, null, null,
	     TO_CHAR);
	 quit;
      }
   }

   targ := findunit(self, arg, FIND_UNIT_SURRO, null);

   if (targ == null)
   {
      act("That person is not here!", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if (not (targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("You can't trip that, silly!", A_SOMEONE, self, null, null,
	  TO_CHAR);
      quit;
   }

   if (targ == self)
   {
      act("You trip over your own feet.", A_HIDEINV, self, null, null,
	  TO_CHAR);
      act("$1n trips over $1s own feet.", A_SOMEONE, self, null, null,
	  TO_ROOM);
      quit;
   }


   if ((targ.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC))
  {
if (not(isset (self.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless you sign the book of blood.",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (not(isset (targ.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless $2e signs the book of blood.",
  A_ALWAYS,self,targ,null,TO_CHAR);
  quit;
  }
  }

   if (not (RACE_IS_MAMMAL(targ.race) or RACE_IS_HUMANOID(targ.race)))
   {
      act("There doesn't seem to be a way to effectively trip $3n.",
          A_SOMEONE, self, null, targ, TO_CHAR);
      quit;
   }

   if ( ((targ.weight - self.weight) > 350) )
   {
      act("You quickly find that $3e is much to heavy to trip...ouch.",
          A_SOMEONE, self, null, targ, TO_CHAR);
      quit;
   }

   if (targ.position <= POSITION_STUNNED)
   {
      act("$3e is already down!", A_SOMEONE, self, null, targ, TO_CHAR);
      quit;
   }

   :trip:
   provoked_attack@basis(targ, self);

   if (self.type == UNIT_ST_PC)
     skilla := self.skills[SKI_TRIP];
   else
     skilla := self.abilities[ABIL_DEX];

   if (targ.type == UNIT_ST_PC)
     skilld := targ.skills[SKI_TRIP];
   else
     skilld := targ.abilities[ABIL_DEX];

   hm := skillresist(self.abilities[ABIL_DEX],
		     targ.abilities[ABIL_DEX],
		     skilla, skilld);
   if ((self.endurance - 2) <= 0)
     act("You are too exhausted to attempt that.", A_ALWAYS, self, null,
         null, TO_CHAR);
   else self.endurance := (self.endurance - 2);
   if (hm < -25)
   {
      change_speed(self, PULSE_VIOLENCE);
      act("You fumble your trip attempt and stumble!.", A_ALWAYS, self,
	  null, targ, TO_CHAR);
      act("$1n ducks clumsily and attempts to sweep your feet!.",
	  A_ALWAYS, self, null, targ, TO_VICT);
      act("$1n attempts to trip $3n but fails miserably.", A_SOMEONE, self,
	  null, targ, TO_NOTVICT);
      quit;
   }

   if (hm < 0)
   {
      change_speed(self, PULSE_VIOLENCE / 2);
      act("You fumble your trip attempt on $3n!.", A_ALWAYS, self, null, targ,
	  TO_CHAR);
      act("$1n ducks and attempts to sweeep your feet!.", A_ALWAYS, self,
	  null, targ, TO_VICT);
      act("$1n attempts to trip $3n but fails.", A_SOMEONE, self, null, targ,
	  TO_NOTVICT);
      quit;
   }

   change_speed(targ, PULSE_VIOLENCE);
   act("You make a quick move and trip $3n.", A_ALWAYS, self, null, targ,
       TO_CHAR);
   act("$1n ducks quickly and sweeps your feet from under you.",
       A_ALWAYS, self, null, targ, TO_VICT);
   act("$1n makes a quick manuever and trips $3n.", A_SOMEONE, self, null,
       targ, TO_NOTVICT);
   quit;
}
dilend




/*
========================================================================= */
/*                               THE SPELLS
 */
/*
 */
/* The spells themselves. These routines are copied onto the spell caster
 */
/* when a spell is cast.
 */
/*
========================================================================= */


dilbegin loc_want(medi:unitptr, tgt : unitptr, arg : string,
		  hm : integer, effect : string);
external
  unitptr unit_room(u : unitptr);

var
  u : unitptr;

code
{

   if (hm < 0)
   {
      act("You feel confused.", A_ALWAYS, self, null, null, TO_CHAR);

      if (hm < -50)
      {
	 act("You realize that $2n attempted to locate you.",
	     A_ALWAYS, tgt, self, null, TO_CHAR);
      }
      quit;
   }

   u := unit_room@basis(tgt);

   if (isset (tgt.charflags,CHAR_OUTLAW))
     act("$2n at $3t", A_SOMEONE, self, tgt, u.title, TO_CHAR);
   else
     act("$2n doesn't seem to be wanted.", A_ALWAYS, self, tgt, null,
TO_CHAR);
   quit;
}
dilend



dilbegin find_want(medi:unitptr, tgt : unitptr, arg : string,
		   hm : integer, effect : string);
external
  string dirstring@function (dr:integer);

var
  dir_string:string;
  i:integer;
code
{
   if (hm < 0)
   {
      act("You feel confused.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (not isset(tgt.charflags,CHAR_OUTLAW))
   {
      act("$2n doesn't seem to be wanted.",
	  A_ALWAYS, self, tgt, null, TO_CHAR);
      quit;
   }

   i := pathto (self,tgt);
   if (i==DIR_IMPOSSIBLE)
   {
      act ("You get the feeling it is impossible from here.",
	   A_ALWAYS,self,null,null,TO_CHAR);
   }
   else if (i==DIR_HERE)
   {
      act ("This is the place.",
	   A_ALWAYS,self,null,null,TO_CHAR);
   }
   else if (i == DIR_ENTER)
   {
      act ("You should enter something here.",
	   A_ALWAYS,self,null,null,TO_CHAR);
   }
   else if (i == DIR_EXIT)
   {
      act ("You should exit this place.",
	   A_ALWAYS,self,null,null,TO_CHAR);
   }
   else
   {
      dir_string := dirstring@function (i);
      act ("You should leave $2t.",
	   A_ALWAYS,self,dir_string,null,TO_CHAR);
   }
   quit;
}
dilend

dilbegin find_path(medi:unitptr, tgt : unitptr, arg : string,
		   hm : integer, effect : string);
external
  string dirstring@function (dr:integer);

var
  dir_string:string;
  i : integer;
code
{

   if (hm < 0)
   {
      act("You feel confused.", A_ALWAYS, self, null, null, TO_CHAR);
      act ("$1n is trying to find you.",A_SOMEONE,self,null,tgt,TO_VICT);
      quit;
   }

   i := pathto (self,tgt);

   if (i==DIR_IMPOSSIBLE)
   {
      act ("You get the feeling it is impossible from here.",
	   A_ALWAYS,self,null,null,TO_CHAR);
   }
   else if (i==DIR_HERE)
   {
      act ("This is the place.",
	   A_ALWAYS,self,null,null,TO_CHAR);
   }
   else if (i == DIR_ENTER)
   {
      act ("You should enter something here.",
	   A_ALWAYS,self,null,null,TO_CHAR);
   }
   else if (i == DIR_EXIT)
   {
      act ("You should exit this place.",
	   A_ALWAYS,self,null,null,TO_CHAR);
   }
   else
   {
      dir_string := dirstring@function (i);
      act ("You should leave $2t.",
	   A_ALWAYS,self,dir_string,null,TO_CHAR);
   }
   quit;
}
dilend


dilbegin refit(medi:unitptr, tgt : unitptr, arg : string,
	       hm : integer, effect : string);
var
   size:string;
   pc:unitptr;
code
{
   if (isset (tgt.flags,UNIT_FL_MAGIC))
   {
      act("That item is too magicly enchanted to resize.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (arg == "")
     pc := null;
   else
   {
      pc := findunit(self, arg, FIND_UNIT_SURRO, null);
      if (pc==null)
      {
         act("No such person here?",
	     A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }
   }

   secure (pc,lostpc);

   if ((tgt.objecttype != ITEM_ARMOR) and
       (tgt.objecttype != ITEM_SHIELD) and
       (tgt.objecttype != ITEM_WEAPON) and
       (tgt.objecttype != ITEM_WORN))
   {
      if ((tgt.manipulate & (MANIPULATE_WEAR_FINGER | MANIPULATE_WEAR_NECK  |
			     MANIPULATE_WEAR_BODY   | MANIPULATE_WEAR_HEAD  |
			     MANIPULATE_WEAR_LEGS   | MANIPULATE_WEAR_FEET  |
			     MANIPULATE_WEAR_HANDS  | MANIPULATE_WEAR_ARMS  |
			     MANIPULATE_WEAR_SHIELD | MANIPULATE_WEAR_ABOUT |
			     MANIPULATE_WEAR_WAIST  | MANIPULATE_WEAR_WRIST |
			     MANIPULATE_WIELD       | MANIPULATE_WEAR_EAR   |
			     MANIPULATE_WEAR_BACK   | MANIPULATE_WEAR_CHEST |
			     MANIPULATE_WEAR_ANKLE)) == 0)
      {
	 act ("The magic disperses on the $3N.",
	      A_ALWAYS, self, null, tgt, TO_CHAR);
	 quit;
      }
   }

   if ((tgt.objecttype == ITEM_ARMOR) or
       (tgt.objecttype == ITEM_SHIELD) or
       (tgt.objecttype == ITEM_WEAPON))
   {
      /* Material quality makes it harder / easier */
      hm := hm - (2*tgt.value[2]);
   }

   if ("$resized" in tgt.extra)
   {
      act("The $2N appear to quiver for a moment, "+
          "but nothing seems to happen.",
	   A_ALWAYS,self,tgt,null,TO_CHAR);
      quit;
   }

   if (pc.height > tgt.height)
     hm := hm - 2*(pc.height - tgt.height);
   else
     hm := hm + 2*(pc.height - tgt.height);

   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   dilcopy ("refit_aff@basis("+itoa(hm)+","+itoa(pc.height)+")",tgt);
   if (pc.height>tgt.height)
     size := "enlarges"
   else
     size := "shrinks";
   act("Your $2n glows brightly as it $3t",
       A_ALWAYS, self, tgt, size, TO_CHAR);
   act("$1n's $2n glows as it $3t",
       A_ALWAYS, self, tgt, size, TO_REST);
   :lostpc:
   quit;
}
dilend

dilbegin recall refit_aff(pwr :integer,size:integer);
var
   i : integer;
   j : integer;
   oldheight:integer;
   parse : stringlist;

code
{
   addextra(self.extra, {"$resized"}, "");

   interrupt(SFB_MSG, TRUE, check);

   heartbeat := PULSE_SEC * 60;
   j:=60;
   oldheight:=self.height;
   self.height:=size;
   set (self.flags,UNIT_FL_MAGIC);
   i:=0;
   while (i < j)
   {
      :loop:
      wait(SFB_TICK , TRUE);
      i := i + 1;
   }

   :check:
   parse := getwords(argument);
   if (parse.[0] == "spl_dispel")
   {
      if (atoi(parse.[1]) >= pwr)
	goto the_end;
   }
   goto loop;

   :the_end:
   subextra(self.extra, "$resized");
   if (self.equip==0)
     act ("$2n returns to its normal size.",
	  A_ALWAYS, self.outside, self, null, TO_CHAR);
   else
   {
      act ("$2n returns to its normal size and falls off.",
	   A_ALWAYS, self.outside, self, null, TO_CHAR);
      act ("$2n returns to its normal size and falls off $1n.",
	   A_ALWAYS, self.outside, self, null, TO_CHAR);
   }
   self.height:=oldheight;
   unset (self.flags,UNIT_FL_MAGIC);
   unequip (self);

   :stop:
   quit;
}
dilend


dilbegin identify_1(medi : unitptr, tgt : unitptr,
		    arg : string,
		    hm : integer, effect : string);
var
  exd : extraptr;

code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   exd := "$identify" in tgt.extra;

   if (exd)
   {
      act(exd.descr, A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (tgt.objecttype == ITEM_LIGHT)
   {
      act("$3n is lightsource with "+itoa(tgt.value[0])+" hours left, "+
             "and an illumination of "+itoa(tgt.value[1])+".",
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_SCROLL)
   {
      act("$3n is a scroll with a magical power of "+itoa(tgt.value[0]),
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_WAND)
   {
      act("$3n is a wand with a magical power of "+itoa(tgt.value[0])+
	" and "+itoa(tgt.value[1])+" charges left.",
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_STAFF)
   {
      act("$3n is a staff with power "+itoa(tgt.value[0])+
	     " and "+itoa(tgt.value[1])+" charges left.",
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_WEAPON)
   {
      act("$3n is a weapon of craftsmanship "+itoa(tgt.value[1])+
	" and a magical modifier of "+itoa(tgt.value[2]),
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_TREASURE)
   {
      act("$3n appears to be nothing less than a treasure!",
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_ARMOR)
   {
      act("$3n is an armour with craftsmanship "+itoa(tgt.value[1])+
	     " and magical modifier "+itoa(tgt.value[2]),
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_POTION)
   {
      act("$3n is a potion with power "+itoa(tgt.value[0]),
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_WORN)
   {
      act("$3n appears to be an item designed to be worn.",
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_NOTE)
   {
      act("$3n seems to be of litterary value.",
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_FOOD)
   {
      act("$3n is consumable.",
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
      if (tgt.value[3] > 0)
	act("It is poisoned.", A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_DRINKCON)
   {
      act("$3n is a drink container.",
	  A_SOMEONE, self, medi, tgt, TO_CHAR);

      if (tgt.value[3] > 0)
	act("It is poisoned.", A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_KEY)
   {
      act("$3n is a key.",
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_MONEY)
   {
      act("$3n is money.",
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_PEN)
   {
      act("$3n is a pen.",
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_BOAT)
   {
      act("$3n is a boat which can carry "+itoa(tgt.capacity)+" pounds.",
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_SHIELD)
   {
      act("$3n is a shield of craftsmanship "+itoa(tgt.value[1])+
	  " and magical bonus "+itoa(tgt.value[2]),
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else if (tgt.objecttype == ITEM_CONTAINER)
   {
      if (isaff(tgt, ID_CORPSE))
	act("It is a dead body.", A_SOMEONE, self, medi, tgt, TO_CHAR);
      else
	act("It is a container.", A_SOMEONE, self, medi, tgt, TO_CHAR);
   }
   else
   {
      act("You gain no additional insight into this item.",
	  A_SOMEONE, self, medi, tgt, TO_CHAR);
   }

   quit;
}
dilend


dilbegin identify_2(medi : unitptr, tgt : unitptr,
		    arg : string,
		    hm : integer, effect : string);
var
  exd : extraptr;
  i   : integer;

code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   i := 0;

   exd := "$identify" in tgt.extra;

   if (exd)
   {
      act(exd.descr, A_ALWAYS, self, null, null, TO_CHAR);
      i := 1;
   }


   exd := "$improved identify" in tgt.extra;

   if (exd)
   {
      act(exd.descr, A_ALWAYS, self, null, null, TO_CHAR);
      i := 1;
   }

   if (i == 0)
     act("There is nothing exceptional to learn about this item.",
	 A_ALWAYS, self, null, null, TO_CHAR);

   quit;
}
dilend

dilbegin control_undead(medi : unitptr, tgt : unitptr,
			arg : string,
			hm : integer, effect : string);
external
   provoked_attack@basis(victim : unitptr, ch : unitptr);
var
  i : integer;
code
{
   secure(tgt, stop);

   if (not RACE_IS_UNDEAD(tgt.race))
     quit;

 if (self.alignment>-1000)
 {
   self.alignment := self.alignment - 50;
   if (self.alignment<-1000) self.alignment:=-1000;
   }


   if (tgt.level > self.level)
     hm := hm - (5*(tgt.level - self.level));

   if (hm >= 0)
   {
      i := dildestroy("undead_obey@basis", tgt);
      i := dildestroy("catchit@basis", tgt);
      i := dildestroy("undead_exec@basis", tgt);
      exec("follow "+self.name, tgt);
      if (tgt.master == self)
      {
         act("$3n is controlled by $1n.",
	     A_HIDEINV, self, null, tgt, TO_ROOM);
         dilcopy("undead_obey@basis("+itoa(hm)+")", tgt);
         dilcopy("undead_exec@basis", tgt);
experience ((-tgt.exp),tgt);
   if (isset(self.pcflags,PC_PK_RELAXED))
   dilcopy ("catchit@basis(1)",tgt);
   else
   dilcopy ("catchit@basis(0)",tgt);

      }
   }
   else
     provoked_attack(tgt, self);

   :stop:
   quit;
}
dilend


dilbegin plague(medi : unitptr, tgt : unitptr,
		arg : string,
		hm : integer, effect : string);
external
   provoked_attack@basis(victim : unitptr, ch : unitptr);

code
{
   provoked_attack(tgt, self);

   if ((not RACE_IS_HUMANOID(tgt.race)) and (not RACE_IS_MAMMAL(tgt.race)))
     return;

   if (dilfind("spl_plague@basis", tgt) or (hm < 0))
   {
      act("Nothing happens.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   act("You feel very ill.", A_ALWAYS, tgt, null, null, TO_CHAR);
   dilcopy("spl_plague@basis("+itoa(hm)+")", tgt);
   quit;
}
dilend

dilbegin madness(medi : unitptr, tgt : unitptr,
		 arg : string,
		 hm : integer, effect : string);
external
   provoked_attack@basis(victim : unitptr, ch : unitptr);
code
{
   provoked_attack(tgt, self);

   if ((not RACE_IS_HUMANOID(tgt.race)) and
       (not RACE_IS_MAMMAL(tgt.race)))
     quit;

   if (hm >= 0)
   {
      act("You feel a battle with your own mind begins.",
	  A_ALWAYS, tgt, null, null, TO_CHAR);
      act("A mad look appears on $1n's face",
	  A_HIDEINV, tgt, null, null, TO_ROOM);
      dilcopy("spl_madness@basis("+itoa(hm)+")", tgt);
   }

   quit;
}
dilend

dilbegin poison(medi : unitptr, tgt : unitptr,
		arg : string,
		hm : integer, effect : string);
external
   provoked_attack@basis(victim : unitptr, ch : unitptr);
code
{
   provoked_attack(tgt, self);

   if (effect != "")
     effect(medi, tgt, hm);

   if (hm >= 0)
   {
      if ((tgt.type == UNIT_ST_OBJ) and
	  ((tgt.objecttype == ITEM_FOOD) or
	   (tgt.objecttype == ITEM_DRINKCON)) and
	  (tgt.value[3] == 0))
	tgt.value[3] := 1 + hm / 10;
      else
      {
	 dilcopy("spl_poison@basis("+itoa(hm)+")", tgt);
      }
   }
   quit;
}
dilend



dilbegin remove_poison(medi : unitptr, tgt : unitptr,
		       arg : string,
		       hm : integer, effect : string);
code
{
   if (hm < 0)
   {
      act("Nothing happens.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (tgt.type == UNIT_ST_OBJ)
   {
      if ((tgt.objecttype == ITEM_FOOD) or
	  (tgt.objecttype == ITEM_DRINKCON))
	tgt.value[3] := 0;
   }
   else
     sendto("spl_rem_poison "+itoa(2*hm), tgt);

   quit;
}
dilend


/* Can be cast on self while asleep! */
dilbegin remove_disease(medi : unitptr, tgt : unitptr,
			arg : string,
			hm : integer, effect : string);
code
{
   if (hm < 0)
   {
      act("Nothing happens.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   sendto("spl_rem_disease "+itoa(2*hm), tgt);
   quit;
}
dilend


dilbegin charge_wand(med : unitptr, targ : unitptr, arg : string,
                     hm : integer, effect : string);

var
   chance    : integer;
   ranroll   : integer;
   c         : integer;
   u         : unitptr;
code
{
   if ((targ == null) or (targ.objecttype != ITEM_WAND))
   {
      act("You don't have a wand to charge!", A_SOMEONE, self, null, null,
	  TO_CHAR);
      quit;
   }

   if (hm <= -20)
   {
      act("The wand glows steadily then suddenly flares in a brilliant " +
	  "purple light!", A_SOMEONE, self, null, null, TO_ALL);
      act("The wand emmits a piercing screech and explodes in a sphere of " +
	  "searing, uncontrolled mana!", A_SOMEONE, self, null, null, TO_ALL);
      foreach(UNIT_ST_PC | UNIT_ST_NPC, u)
      {
	 cast_spell(SPL_LIGHTNING_2, self, targ, u);
      }
      destroy(targ);
      quit;
   }

   if (hm <= 0)
   {
      act("The wand glows slightly then sputters and goes dim.", A_SOMEONE,
	  self, null, null, TO_ALL);
      act("You fail to charge the wand.", A_SOMEONE, self, null, null,
	  TO_CHAR);
      quit;
   }

   act("The wand glows in a soft white light which slowly subsides.",
       A_SOMEONE, self, null, null, TO_ALL);
   c := (hm / 25);

   if (c < 1) c := 1;

   if ( (targ.value[1] + c) > targ.value[4])
   {
      act("You have recharged the wand enough to use it " +
	  itoa((targ.value[4] - targ.value[1]))+
	  " more times.", A_SOMEONE, self, null, null, TO_CHAR);
      targ.value[1] := targ.value[4];
   }
   else
   {
      targ.value[1] := (targ.value[1] + c);
      act("You have recharged the wand enough to use it " +itoa(c)+
	  " more times.", A_SOMEONE, self, null, null, TO_CHAR);
   }
   quit;
}
dilend



dilbegin charge_staff(med : unitptr, targ : unitptr, arg : string,
                     hm : integer, effect : string);
/* charge staff should only be castable while standing and not in combat */
var
   chance    : integer;
   ranroll   : integer;
   c         : integer;
   u         : unitptr;
code
{
   if ((targ == null) or (targ.objecttype != ITEM_STAFF))
   {
      act("You don't have a staff to charge!", A_SOMEONE, self, null, null,
          TO_CHAR);
      quit;
   }

   if (hm <= -20)
   {
      act("The staff glows steadily then suddenly flares in a brilliant "+
	  "purple light!", A_SOMEONE, self, null, null, TO_ALL);
      act("The staff emmits a piercing screech and explodes in a sphere of " +
          "searing, uncontrolled mana!", A_SOMEONE, self, null, null, TO_ALL);
      foreach(UNIT_ST_PC | UNIT_ST_NPC, u)
      {
	 cast_spell(SPL_LIGHTNING_2, self, targ, u);
      }
      destroy(targ);
      quit;
   }

   if (hm <= 0)
   {
      act("The staff glows slightly then sputters and goes dim.", A_SOMEONE,
          self, null, null, TO_ALL);
      act("You fail to charge the staff.", A_SOMEONE, self, null, null,
          TO_CHAR);
      quit;
   }

   act("The staff glows in a soft white light which slowly subsides.",
       A_SOMEONE, self, null, null, TO_ALL);
   c := (hm / 25);
   if ( c < 1) c := 1;
   if ( (targ.value[1] + c) > targ.value[4])
   {
      act("You have recharged the wand enough to use " +
          itoa((targ.value[4] - targ.value[1]))+
          " more time(s).", A_SOMEONE, self, null, null, TO_CHAR);
      targ.value[1] := targ.value[4];
   }
   else
   {
      targ.value[1] := (targ.value[1] + c);
      act("You have recharged the wand enough to use " +itoa(c)+
	  " more time(s).", A_SOMEONE, self, null, null, TO_CHAR);
   }
   quit;
}
dilend


dilbegin mending(med : unitptr, targ : unitptr, arg : string, hm : integer,
		 effect : string);
var
   fix_ran : integer;

code
{
  if (hm <= 0)
  {
     act("You fail.", A_SOMEONE, self, null, null, TO_CHAR);
     quit;
  }

  if (targ.hp == targ.max_hp)
  {
     act("Your spell does nothing more for the item.", A_SOMEONE, self,
	 null, null, TO_CHAR);
     quit;
  }

  if (targ.hp <= 0)
  {
     act("Your spell is too weak to mend the $2N",
	 A_SOMEONE, self, targ, null, TO_CHAR);
     quit;
  }

  if (targ.hp <= (targ.max_hp / 2))
  {
     act("Your spell is too weak to mend an item so badly damaged.",
	 A_SOMEONE, self, targ, null, TO_CHAR);
     quit;
  }

  targ.max_hp := ( (7 *(targ.max_hp / 8)) );
  fix_ran := rnd(1, (targ.max_hp / 6));
  if ( (targ.hp + fix_ran) > (targ.max_hp) )
    targ.hp := (targ.max_hp);
  else targ.hp := (targ.hp + fix_ran);

  act("Your $2n glows with a warm light...", A_SOMEONE, self, targ, null,
      TO_CHAR);

  act("$1n's $2n glows with a warm light...", A_SOMEONE, self, targ, null,
      TO_ROOM);
  quit;
}
dilend


dilbegin repair(med : unitptr, targ : unitptr, arg : string, hm : integer,
		effect : string);
var
   fix_ran : integer;

code
{
   if (hm <= 0)
   {
      act("You fail.", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if (targ.hp == targ.max_hp)
   {
      act("Your spell does nothing more for the item.", A_SOMEONE, self,
          null, null, TO_CHAR);
      quit;
   }

   if (targ.hp <= 0)
   {
      act("Your spell is too weak to mend the $2N",
	  A_SOMEONE, self, targ, null, TO_CHAR);
      quit;
   }

   if (targ.hp <= (targ.max_hp / 4))
   {
      act("Your spell is too weak to mend an item so badly damaged.",
	  A_SOMEONE, self, targ, null, TO_CHAR);
      quit;
   }
   targ.max_hp := ( (7 * (targ.max_hp / 8)) );
   fix_ran := rnd( (targ.max_hp / 6), (targ.max_hp / 3) );
   if ( (targ.hp + fix_ran) > (targ.max_hp) )
     targ.hp := (targ.max_hp);
   else targ.hp := (targ.hp + fix_ran);
   act("Your $2n glows with a warm light...", A_SOMEONE, self, targ, null,
       TO_CHAR);
   act("$1n's $2n glows with a warm light...", A_SOMEONE, self, targ, null,
       TO_ROOM);
   quit;
}
dilend


dilbegin reconstruct(med : unitptr, targ : unitptr, arg : string,
                    hm : integer, effect: string);

var
   max_heal : integer;
   new_item : unitptr;
   fix_ran  : integer;
   old_max  : integer;

code
{
   if (hm <= 0)
   {
      act("You fail.", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if (targ.hp == targ.max_hp)
   {
      act("Your spell does nothing more for the item.", A_SOMEONE, self,
          null, null, TO_CHAR);
      quit;
   }

   if (targ.hp <= 0)
   {
      act("Your spell is too weak to mend the $2N",
	  A_SOMEONE, self, targ, null, TO_CHAR);
      quit;
   }

   if (targ.hp <= (targ.max_hp / 4))
   {
      act("Your spell is too weak to mend an item so badly damaged.",
	  A_SOMEONE, self, targ, null, TO_CHAR);
      quit;
   }

   targ.max_hp := ( (15 * (targ.max_hp / 16)) );
   fix_ran := rnd( (targ.max_hp / 6), (targ.max_hp / 3) );
   if ( (targ.hp + fix_ran) > (targ.max_hp) )
     targ.hp := (targ.max_hp);
   else targ.hp := (targ.hp + fix_ran);
   act("Your $2n glows with a warm light...", A_SOMEONE, self, targ, null,
       TO_CHAR);
   act("$1n's $2n glows with a warm light...", A_SOMEONE, self, targ, null,
       TO_ROOM);
   quit;
}
dilend


dilbegin sending(med : unitptr, targ : unitptr, arg : string, hm : integer,
		 effect : string);

var
   room   : unitptr;
   recept : unitptr;
   i      : integer;

code
{
   heartbeat := (PULSE_SEC*6);

   if (hm <= 0)
   {
      act("Nothing happens.", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   recept := findunit(self, arg, FIND_UNIT_SURRO | FIND_UNIT_WORLD, null);

   if ( (recept == null) or (not (visible(self, recept))) )
   {
      act("You cannot locate the target's destination.", A_SOMEONE, self,
	  targ, recept, TO_CHAR);
      quit;
   }

   if ( (recept.type != UNIT_ST_PC) and (recept.type != UNIT_ST_NPC) )
   {
      act("You can only send items to players or monsters.", A_SOMEONE, self,
	  targ, recept, TO_CHAR);
      quit;
   }

   room := targ.outside;
   while ( (room.type != UNIT_ST_ROOM) and
	  (not(isset(room.flags, UNIT_FL_NO_TELEPORT))) )
   {
      room := room.outside;
   }

   if ( (isset(targ.flags, UNIT_FL_NO_TELEPORT)) or
       (isset(room.flags, UNIT_FL_NO_TELEPORT)) )
   {
      act("Something here prevents your spell.", A_SOMEONE,
	  self, targ, recept, TO_CHAR);
      quit;
   }

   room := recept.outside;
   while ( (room.type != UNIT_ST_ROOM) and
          (not(isset(room.flags, UNIT_FL_NO_TELEPORT))) )
   {
      room := room.outside;
   }

   if ( (isset(recept.flags, UNIT_FL_NO_TELEPORT)) or
       (isset(room.flags, UNIT_FL_NO_TELEPORT)) )
   {
      act("Something prevents you from sending to that person.", A_SOMEONE,
	  self, targ, recept, TO_CHAR);
      quit;
   }

   if (hm <= 5)
   {
      act("A small swirling disk of gray forms above you...", A_SOMEONE, self,
	  targ, null, TO_CHAR);
      act("A small swirling disk of gray forms above $1n.", A_SOMEONE, self,
	  targ, null, TO_ROOM);
      act("Slowly, your $2n rises toward the disk...", A_SOMEONE, self, targ,
	  null, TO_CHAR);
      act("Slowly, $1n's $2n rises toward the disk...", A_SOMEONE, self, targ,
	  null, TO_ROOM);
      act("As it touches the disk, you feel something go wrong!", A_SOMEONE,
	  self, targ, null, TO_CHAR);
      act("The swirling rift turns a violent red and suddenly explodes " +
	  "in a brilliant light, taking $2n with it!", A_SOMEONE, self, targ,
	  null, TO_ALL);
      destroy(targ);
      quit;
   }

   act("A small swirling disk of gray forms above you...", A_SOMEONE, self,
       targ, null, TO_CHAR);
   act("A small swirling disk of gray forms above $1n.", A_SOMEONE, self,
       targ, null, TO_ROOM);
   act("Slowy, your $2n rises toward the disk...", A_SOMEONE, self, targ,
       null, TO_CHAR);
   act("Slowly, $1n's $2n rises toward the disk...", A_SOMEONE, self, targ,
       null, TO_ROOM);
   act("$2n touches the swirling rift and vanishes in a flash of light!",
       A_SOMEONE, self, targ, null, TO_ALL);

   link(targ, recept.outside);

   act("Suddenly, a swirling grey rift forms above you...", A_SOMEONE, recept,
       targ, null, TO_CHAR);
   act("Suddenly, a swirling grey rift forms above $1n...", A_SOMEONE, recept,
       targ, null, TO_ROOM);
   act("$2n falls from the rift and lands at your feet.",
       A_SOMEONE, recept, targ,
       null, TO_CHAR);
   act("$2n falls from the rift and lands at $1n's feet.",
       A_SOMEONE, recept, targ,
       null, TO_ROOM);
   act("The swirling rift disappears in a flash of light!", A_SOMEONE, recept,
       targ, null, TO_ALL);
   quit;
}
dilend


dilbegin summon_earth(medi : unitptr, tgt : unitptr, arg : string,
		      hm : integer, effect : string);
var
   u : unitptr;
code
{
   if (hm < 0)
   {
      act("The ground shakes a bit.", A_SOMEONE,self,null,null,
	  TO_ALL);
      quit;
   }

   u := load("earth_elm@basis");
   link(u, self.outside);

   act("The earth opens as $2n is summoned before you.",
       A_HIDEINV, self, u, null, TO_CHAR);

   act("The earth opens and $2n appears before $1n", A_HIDEINV,
       self, u, null, TO_ROOM);

   dilcopy("magic_summoned@basis("+itoa(hm)+")", u);
   dilcopy("master_servant@basis()", u);
   if (isset(self.pcflags,PC_PK_RELAXED))
   dilcopy ("catchit@basis(1)",u);
   else
   dilcopy ("catchit@basis(0)",u);

   exec("follow "+self.name, u);
   quit;
}
dilend



dilbegin summon_air(medi : unitptr, tgt : unitptr, arg : string,
		 	hm : integer, effect : string);
var
   u : unitptr;
code
{
   if (hm < 0)
   {
      act("The ground shakes a bit.", A_SOMEONE,self,null,null,
	  TO_ALL);
      quit;
   }

   u := load("air_elm@basis");
   link(u, self.outside);

   act("The portal of air opens and $2n appears before you.",
       A_HIDEINV, self, u, null, TO_CHAR);

   act("The portal of air opens, and $2n emerges before $1n",
       A_HIDEINV, self, u, null, TO_ROOM);

   dilcopy("magic_summoned@basis("+itoa(hm)+")", u);
   dilcopy("master_servant@basis()", u);
   if (isset(self.pcflags,PC_PK_RELAXED))
   dilcopy ("catchit@basis(1)",u);
   else
   dilcopy ("catchit@basis(0)",u);

   exec("follow "+self.name, u);
   quit;
}
dilend


dilbegin summon_water(medi : unitptr, tgt : unitptr, arg : string,
		 	hm : integer, effect : string);
var
	u : unitptr;
code
{
   if (hm < 0)
   {
      act("The ground shakes a bit.", A_SOMEONE,self,null,null,
	  TO_ALL);
      quit;
   }

   u := load("water_elm@basis");
   link(u, self.outside);

   act("From the column of water $2n emerges to stand"+
       " before you.", A_HIDEINV, self, u, null, TO_CHAR);

   act("From the column of water $2n emerges to stand"+
       " before $1n.", A_HIDEINV, self, u, null, TO_ROOM);

   dilcopy("magic_summoned@basis("+itoa(hm)+")", u);
   dilcopy("master_servant@basis()", u);
   if (isset(self.pcflags,PC_PK_RELAXED))
   dilcopy ("catchit@basis(1)",u);
   else
   dilcopy ("catchit@basis(0)",u);


   exec("follow "+self.name, u);
   quit;

}
dilend


dilbegin summon_fire(medi : unitptr, tgt : unitptr, arg : string,
		 	hm : integer, effect : string);
var
   u : unitptr;
code
{
   if (hm < 0)
   {
      act("The ground shakes a bit.", A_SOMEONE,self,null,null,
	  TO_ALL);
      quit;
   }

   u := load("fire_elm@basis");
   link(u, self.outside);

   act("In a flash of fire and light, $2n emerges to stand before"+
       " you!", A_HIDEINV, self, u, null, TO_CHAR);

   act("In a flash of fire and light $2n appears to stand before "+
       "$1n.", A_HIDEINV, self, u, null, TO_ROOM);

   dilcopy("magic_summoned@basis("+itoa(hm)+")", u);
   dilcopy("master_servant@basis()", u);
   if (isset(self.pcflags,PC_PK_RELAXED))
   dilcopy ("catchit@basis(1)",u);
   else
   dilcopy ("catchit@basis(0)",u);


   exec("follow "+self.name, u);
   quit;

}
dilend


dilbegin demon_summon(medi : unitptr, tgt : unitptr, arg : string,
		      hm : integer, effect : string);
var
   u : unitptr;

code
{
   if (hm < 0)
   {
      act("You lose control of the portal!",
	  A_HIDEINV, self, u, null, TO_CHAR);

      act("A large portal opens and a beast emerges!",
	  A_HIDEINV, self, u, null, TO_ROOM);
      u := load("demon@basis");
      exec("follow "+self.name, u);
      exec("say Thank you "+self.name+", for bringing me here "+
	   "unbonded!", u);
      exec("kill "+self.name, u);
      quit;
   }

   u := load("demon@basis");
   link(u, self.outside);

   act("A large portal opens, and $2n steps through to stand before you.",
       A_HIDEINV, self, u, null, TO_CHAR);

   act("A large portal of fire opens, and $2n steps through to stand "+
       "before $1n.", A_HIDEINV, self, u, null, TO_REST);

   dilcopy("magic_summoned@basis("+itoa(hm)+")", u);
   dilcopy("master_servant@basis()", u);
   if (isset(self.pcflags,PC_PK_RELAXED))
   dilcopy ("catchit@basis(1)",u);
   else
   dilcopy ("catchit@basis(0)",u);


   exec("follow "+self.name, u);
   quit;
}
dilend


dilbegin devil_summon(medi : unitptr, tgt : unitptr, arg : string,
		      hm : integer, effect : string);
var
   u : unitptr;
code
{
   if (hm < 0)
   {
      act("A portal of fire opens and a beast steps through!",
	  A_SOMEONE, self, null, null, TO_ALL);
      u := load("devil@basis");
      link(u, self.outside);
      exec("follow "+self.name, u);
      exec("say Ahh, to be summoned here and free!", u);
      exec("kill "+self.name, u);
      quit;
   }

   u := load("devil@basis");
   link(u, self.outside);

   act("A portal of fire opens and $2n emerges to stand before you.",
       A_HIDEINV, self, u, null, TO_CHAR);

   act("A portal of fire opens and $2n emerges to stand before $1n.",
       A_HIDEINV, self, u, null, TO_REST);

   dilcopy("magic_summoned@basis("+itoa(hm)+")", u);
   dilcopy("master_servant@basis()", u);
   if (isset(self.pcflags,PC_PK_RELAXED))
   dilcopy ("catchit@basis(1)",u);
   else
   dilcopy ("catchit@basis(0)",u);


   exec("follow "+self.name, u);
   quit;
}
dilend


dilbegin energy_bolt(medi : unitptr, tgt : unitptr, arg : string,
		      hm : integer, effect : string);
var
   u : unitptr;

code
{
   hm := attack_spell(SPL_ENERGY_BOLT, self, medi, tgt, 0);
   quit;
}
dilend

dilbegin clenched_fist(medi : unitptr, tgt : unitptr, arg : string,
		       hm : integer, effect : string);
var
   u : unitptr;
code
{
   hm := attack_spell(SPL_CLENCHED_FIST, self, medi, tgt, 0);
   quit;
}
dilend


dilbegin dispel_magic(medi : unitptr, tgt : unitptr,
		      arg : string,
		      hm : integer, effect : string);
          var
          count:integer;
code
{
   if ((hm < 0) or (self.endurance<=20))
   {
      act("Nothing happens.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

      hm := hm/10+1;
      if (hm>15)
	hm := 15;

count:=0;
interrupt (SFB_MSG , "inc despel counter" == argument,inc_count);
   sendto("spl_dispel "+itoa(hm), tgt);
   interrupt(SFB_DEAD, activator == tgt, stop);

   :loop:
   count:=count+1;
   if (isaff(tgt, ID_BLESS))
     subaff(tgt, ID_BLESS);
   else if (isaff(tgt, ID_DETECT_ALIGN))
     subaff(tgt, ID_DETECT_ALIGN);
   else if (isaff(tgt, ID_DETECT_INVISIBLE))
     subaff(tgt, ID_DETECT_INVISIBLE);
   else if (isaff(tgt, ID_DETECT_MAGIC))
     subaff(tgt, ID_DETECT_MAGIC);
   else if (isaff(tgt, ID_DETECT_POISON))
     subaff(tgt, ID_DETECT_POISON);
   else if (isaff(tgt, ID_DETECT_UNDEAD))
     subaff(tgt, ID_DETECT_UNDEAD);
   else if (isaff(tgt, ID_DETECT_CURSE))
     subaff(tgt, ID_DETECT_CURSE);
   else if (isaff(tgt, ID_DETECT_LIFE))
     subaff(tgt, ID_DETECT_LIFE);
   else if (isaff(tgt, ID_ENCHANT_WEAPON))
     subaff(tgt, ID_ENCHANT_WEAPON);
   else if (isaff(tgt, ID_ENCHANT_ARMOUR))
     subaff(tgt, ID_ENCHANT_ARMOUR);
   else if (isaff(tgt, ID_ABSORBTION))
     subaff(tgt, ID_ABSORBTION);
   else if (isaff(tgt, ID_INVISIBILITY))
     subaff(tgt, ID_INVISIBILITY);
   else if (isaff(tgt, ID_HOLD))
     subaff(tgt, ID_HOLD);
   else if (isaff(tgt, ID_CHARM))
     subaff(tgt, ID_CHARM);
   else if (isaff(tgt, ID_MAGIC_LIGHT))
     subaff(tgt, ID_MAGIC_LIGHT);
   else if (isaff(tgt, ID_MAGIC_DARK))
     subaff(tgt, ID_MAGIC_DARK);
   else if (isaff(tgt, ID_SPL_RAISE_MAG))
     subaff(tgt, ID_SPL_RAISE_MAG);
   else if (isaff(tgt, ID_SPL_RAISE_DIV))
     subaff(tgt, ID_SPL_RAISE_DIV);
   else if (isaff(tgt, ID_SPL_RAISE_STR))
     subaff(tgt, ID_SPL_RAISE_STR);
   else if (isaff(tgt, ID_SPL_RAISE_DEX))
     subaff(tgt, ID_SPL_RAISE_DEX);
   else if (isaff(tgt, ID_SPL_RAISE_CON))
     subaff(tgt, ID_SPL_RAISE_CON);
   else if (isaff(tgt, ID_SPL_RAISE_CHA))
     subaff(tgt, ID_SPL_RAISE_CHA);
   else if (isaff(tgt, ID_SPL_RAISE_BRA))
     subaff(tgt, ID_SPL_RAISE_BRA);
   else if (isaff(tgt, ID_SPL_RAISE_HPP))
     subaff(tgt, ID_SPL_RAISE_HPP);
   else if (isaff(tgt, ID_SPL_RAISE_DIVINE))
     subaff(tgt, ID_SPL_RAISE_DIVINE);
   else if (isaff(tgt, ID_SPL_RAISE_SUMMONING))
     subaff(tgt, ID_SPL_RAISE_SUMMONING);
   else if (isaff(tgt, ID_SPL_RAISE_MIND))
     subaff(tgt, ID_SPL_RAISE_MIND);
   else if (isaff(tgt, ID_SPL_RAISE_HEAT))
     subaff(tgt, ID_SPL_RAISE_HEAT);
   else if (isaff(tgt, ID_SPL_RAISE_COLD))
     subaff(tgt, ID_SPL_RAISE_COLD);
   else if (isaff(tgt, ID_SPL_RAISE_CELL))
     subaff(tgt, ID_SPL_RAISE_CELL);
   else if (isaff(tgt, ID_SPL_RAISE_INTERNAL))
     subaff(tgt, ID_SPL_RAISE_INTERNAL);
   else if (isaff(tgt, ID_SPL_RAISE_EXTERNAL))
     subaff(tgt, ID_SPL_RAISE_EXTERNAL);
   else if (isaff(tgt, ID_RAISE_MAG))
     subaff(tgt, ID_RAISE_MAG);
   else if (isaff(tgt, ID_RAISE_DIV))
     subaff(tgt, ID_RAISE_DIV);
   else if (isaff(tgt, ID_RAISE_STR))
     subaff(tgt, ID_RAISE_STR);
   else if (isaff(tgt, ID_RAISE_DEX))
     subaff(tgt, ID_RAISE_DEX);
   else if (isaff(tgt, ID_RAISE_CON))
     subaff(tgt, ID_RAISE_CON);
   else if (isaff(tgt, ID_RAISE_CHA))
     subaff(tgt, ID_RAISE_CHA);
   else if (isaff(tgt, ID_RAISE_BRA))
     subaff(tgt, ID_RAISE_BRA);
   else if (isaff(tgt, ID_RAISE_HPP))
     subaff(tgt, ID_RAISE_HPP);
   else if (isaff(tgt, ID_RAISE_DIVINE))
     subaff(tgt, ID_RAISE_DIVINE);
   else if (isaff(tgt, ID_RAISE_SUMMONING))
     subaff(tgt, ID_RAISE_SUMMONING);
   else if (isaff(tgt, ID_RAISE_MIND))
     subaff(tgt, ID_RAISE_MIND);
   else if (isaff(tgt, ID_RAISE_HEAT))
     subaff(tgt, ID_RAISE_HEAT);
   else if (isaff(tgt, ID_RAISE_COLD))
     subaff(tgt, ID_RAISE_COLD);
   else if (isaff(tgt, ID_RAISE_CELL))
     subaff(tgt, ID_RAISE_CELL);
   else if (isaff(tgt, ID_RAISE_INTERNAL))
     subaff(tgt, ID_RAISE_INTERNAL);
   else if (isaff(tgt, ID_RAISE_EXTERNAL))
     subaff(tgt, ID_RAISE_EXTERNAL);
   else if (isaff(tgt, ID_POISON))
     subaff(tgt, ID_POISON);
   else if (isaff(tgt, ID_SPEED))
     subaff(tgt, ID_SPEED);
   else
     quit;
:inc_count:
if (self.endurance<20) self.endurance:=0;
else
self.endurance:=self.endurance-20;
if (self.endurance==0)
  {
   self.position:=POSITION_STUNNED;
   quit;
   }

if (count==hm)
  quit;

   goto loop;

:stop:
quit;
}
dilend
dilbegin fire_breath(medi : unitptr, tgt : unitptr, arg : string,
		     hm : integer, effect : string);
var
   u : unitptr;
   i : integer;
   mast:unitptr;
code
{
   if (medi.level <= 20)
      i := SPL_FIREBALL_1;
   else if (medi.level <= 40)
      i := SPL_FIREBALL_2;
   else if (medi.type==UNIT_ST_NPC)
      i := SPL_FIRE_BREATH;
else
      i := SPL_FIREBALL_3;
   mast := self.master;
   if (not(self.master))
     mast := self;

   foreach(UNIT_ST_PC|UNIT_ST_NPC, u)
   {
   if (u.minv>=200) continue;
   if (((u.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC)) and
   ((not (isset(u.pcflags,PC_PK_RELAXED))) or
   (not (isset (self.pcflags,PC_PK_RELAXED))))) continue;

   if ((u.master != mast) and (u != mast) and (u != self))
       hm := attack_spell(i, self, medi, u, 0);
       }

   quit;
}
dilend

/* Adjust fire type against the level of the caster - if no level the */
/* toughest is chosen                                                 */
dilbegin frost_breath(medi : unitptr, tgt : unitptr, arg : string,
		      hm : integer, effect : string);
var
   u : unitptr;
   i : integer;
   mast:unitptr;
code
{
   if (medi.level <= 20)
      i := SPL_FROSTBALL_1;
   else if (medi.level <= 40)
      i := SPL_FROSTBALL_2;
   else if (medi.type==UNIT_ST_NPC)
      i := SPL_FROST_BREATH;
   else
      i := SPL_FROSTBALL_3;

   mast := self.master;
   if (not(self.master))
     mast := self;

   foreach(UNIT_ST_PC|UNIT_ST_NPC, u)
   {
   if (u.minv>=200) continue;
   if (((u.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC)) and
   ((not (isset(u.pcflags,PC_PK_RELAXED))) or
   (not (isset (self.pcflags,PC_PK_RELAXED))))) continue;

   if ((u.master != mast) and (u != mast) and (u != self))
        hm := attack_spell(i, self, medi, u, 0);
   }
   quit;
}
dilend

/* Adjust fire type against the level of the caster - if no level the */
/* toughest is chosen                                                 */
dilbegin lightning_br(medi : unitptr, tgt : unitptr,
 	              arg : string,
		      hm : integer, effect : string);
external provoked_attack@basis(victim : unitptr, ch : unitptr);
var
   u : unitptr;
   i : integer;
mast:unitptr;
code
{
   if (medi.level <= 20)
      i := SPL_LIGHTNING_1;
   else if (medi.level <= 40)
      i := SPL_LIGHTNING_2;
   else if (medi.type==UNIT_ST_NPC)
      i := SPL_LIGHTNING_BREATH;
   else
      i := SPL_LIGHTNING_3;

   mast := self.master;
   if (not(self.master))
     mast := self;

   foreach(UNIT_ST_PC|UNIT_ST_NPC, u)
   {
   if (u.minv>=200) continue;
   if (((u.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC)) and
   ((not (isset(u.pcflags,PC_PK_RELAXED))) or
   (not (isset (self.pcflags,PC_PK_RELAXED))))) continue;
   if ((u.master != mast) and (u != mast) and (u != self))
        hm := attack_spell(i, self, medi, u, 0);
   }
   quit;
}
dilend


/* Adjust fire type against the level of the caster - if no level the */
/* toughest is chosen                                                 */
dilbegin acid_breath(medi : unitptr, tgt : unitptr,
 	             arg : string,
		     hm : integer, effect : string);
var
   u : unitptr;
   i : integer;
mast:unitptr;
code
{
   if (medi.level <= 20)
      i := SPL_ACIDBALL_1;
   else if (medi.level <= 40)
      i := SPL_ACIDBALL_2;
   else if (medi.type==UNIT_ST_NPC)
      i := SPL_ACID_BREATH;
   else
      i := SPL_ACIDBALL_3;

   mast := self.master;
   if (not(self.master))
     mast := self;

   foreach(UNIT_ST_PC|UNIT_ST_NPC, u)
   {
   if (u.minv>=200) continue;
   if (((u.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC)) and
   ((not (isset(u.pcflags,PC_PK_RELAXED))) or
   (not (isset (self.pcflags,PC_PK_RELAXED))))) continue;
   if ((u.master != mast) and (u != mast) and (u != self))
        hm := attack_spell(i, self, medi, u, 0);
   }
   quit;
}
dilend


/* Adjust fire type against the level of the caster - if no level the */
/* toughest is chosen                                                 */
dilbegin gas_breath(medi : unitptr, tgt : unitptr,
 	            arg : string,
		    hm : integer, effect : string);
var
   u : unitptr;
   i : integer;
mast:unitptr;
code
{
   if (medi.level <= 20)
      i := SPL_STINKING_CLOUD_1;
   else if (medi.level <= 40)
      i := SPL_STINKING_CLOUD_2;
   else if (medi.type==UNIT_ST_NPC)
      i := SPL_GAS_BREATH;
   else
      i := SPL_STINKING_CLOUD_3;

   mast := self.master;
   if (not(self.master))
     mast := self;

   foreach(UNIT_ST_PC|UNIT_ST_NPC, u)
   {
   if (u.minv>=200) continue;
   if (((u.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC)) and
   ((not (isset(u.pcflags,PC_PK_RELAXED))) or
   (not (isset (self.pcflags,PC_PK_RELAXED))))) continue;
   if ((u.master != mast) and (u != mast) and (u != self))
        hm := attack_spell(i, self, medi, u, 0);
   }
   quit;
}
dilend


/* Adjust fire type against the level of the caster - if no level the */
/* toughest is chosen                                                 */
dilbegin light_breath(medi : unitptr, tgt : unitptr,
 	              arg : string,
		      hm : integer, effect : string);
var
   u : unitptr;
   i : integer;
mast:unitptr;
code
{
   if (medi.level <= 20)
      i := SPL_COLOURSPRAY_1;
   else if (medi.level <= 40)
      i := SPL_COLOURSPRAY_2;
   else if (medi.type==UNIT_ST_NPC)
      i := SPL_LIGHT_BREATH;
   else
      i := SPL_COLOURSPRAY_3;

   mast := self.master;
   if (not(self.master))
     mast := self;

   foreach(UNIT_ST_PC|UNIT_ST_NPC, u)
   {
   if (u.minv>=200) continue;
   if (((u.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC)) and
   ((not (isset(u.pcflags,PC_PK_RELAXED))) or
   (not (isset (self.pcflags,PC_PK_RELAXED))))) continue;
   if ((u.master != mast) and (u != mast) and (u != self))
        hm := attack_spell(i, self, medi, u, 0);
   }
   quit;
}
dilend

dilbegin cone_shard(medi : unitptr, tgt : unitptr, arg : string,
		      hm : integer, effect : string);
var
code
{
   hm := attack_spell(SPL_CONE_SHARD, self, medi, tgt, 0);
   quit;
}
dilend

dilbegin shard_breath(medi : unitptr, tgt : unitptr,
 	              arg : string,
		      hm : integer, effect : string);
var
   u : unitptr;
   i : integer;
mast:unitptr;
code
{
      i := SPL_SHARD_BREATH;

   mast := self.master;
   if (not(self.master))
     mast := self;

   foreach(UNIT_ST_PC|UNIT_ST_NPC, u)
   {
   if (u.minv>=200) continue;
   if (((u.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC)) and
   ((not (isset(u.pcflags,PC_PK_RELAXED))) or
   (not (isset (self.pcflags,PC_PK_RELAXED))))) continue;
   if ((u.master != mast) and (u != mast) and (u != self))
        hm := attack_spell(i, self, medi, u, 0);
   }
   quit;
}
dilend

dilbegin sonic_breath(medi : unitptr, tgt : unitptr,
 	              arg : string,
		      hm : integer, effect : string);
var
   u : unitptr;
   i : integer;
mast:unitptr;
code
{
      i := SPL_SONIC_BREATH;

   mast := self.master;
   if (not(self.master))
     mast := self;

   foreach(UNIT_ST_PC|UNIT_ST_NPC, u)
   {
   if (u.minv>=200) continue;
   if (((u.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC)) and
   ((not (isset(u.pcflags,PC_PK_RELAXED))) or
   (not (isset (self.pcflags,PC_PK_RELAXED))))) continue;
   if ((u.master != mast) and (u != mast) and (u != self))
        hm := attack_spell(i, self, medi, u, 0);
   }
   quit;
}
dilend


dilbegin meteor_shower(medi : unitptr, tgt : unitptr, arg : string,
		       hm : integer, effect : string);
var
   u    : unitptr;
   mast : unitptr;
code
{

   mast := self.master;
   if (not(self.master))
     mast := self;

   foreach(UNIT_ST_PC|UNIT_ST_NPC, u)
   {
   if (u.minv>=200) continue;
   if (((u.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC)) and
   ((not (isset(u.pcflags,PC_PK_RELAXED))) or
   (not (isset (self.pcflags,PC_PK_RELAXED))))) continue;


   if ((u.master != mast) and (u != mast) and (u != self))
        hm := attack_spell(SPL_METEOR_SHOWER, self, medi, u, 0);
   }
   quit;
}
dilend

dilbegin sun_beam(medi : unitptr, tgt : unitptr,
                 arg : string, hm : integer, effect : string);
var
   u : unitptr;

code
{
   hm := 0;
   u := self.outside;

   while (u)
   {
      if (isset(u.flags, UNIT_FL_NO_WEATHER | UNIT_FL_INDOORS))
      {
         act("There is no access to the forces of nature from here.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }
      u := u.outside;
   }

   if (weather != SKY_CLOUDLESS)
   {
      act("The skies are not clear.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if ((mudhour < 5) or (mudhour >= 21))
   {
      act("The sun has not rised yet.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   /* Most powerful at noon */
   if (mudhour < 12)
     hm := 18*(mudhour - 12);
   else
     hm := -15*(mudhour - 12);

   if (RACE_IS_UNDEAD(tgt.race))
     hm := hm + 100;

   hm := attack_spell(SPL_SUN_BEAM, self, medi, tgt, hm);
   quit;
}
dilend


dilbegin solar_flare(medi : unitptr, tgt : unitptr,
                 arg : string,
                 hm : integer, effect : string);
var
   u : unitptr;

code
{
   hm := 0;
   u := self.outside;

   while (u)
   {
      if (isset(u.flags, UNIT_FL_NO_WEATHER | UNIT_FL_INDOORS))
      {
         act("There is no access to the forces of nature from here.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }
      u := u.outside;
   }

   if (weather != SKY_CLOUDLESS)
   {
      act("The skies are not clear.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if ((mudhour < 5) or (mudhour >= 21))
   {
      act("The sun has not rised yet.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   /* Most powerful at noon */
   if (mudhour < 12)
     hm := 18*(mudhour - 12);
   else
     hm := -15*(mudhour - 12);

   if (RACE_IS_UNDEAD(tgt.race))
     hm := hm + 100;

   hm := hm*3;
   hm := attack_spell(SPL_SOLAR_FLARE, self, medi, tgt, hm);
   quit;
}
dilend


dilbegin mlight(medi:unitptr, tgt : unitptr, arg : string,
		hm : integer, effect : string);
external
   integer skill_duration@basis(i : integer);

code
{
   if (isaff(tgt, ID_MAGIC_LIGHT))
     return;

   if (hm < 0)
     quit;

   hm := skill_duration(hm);

   /* 1 light source */
   addaff(tgt, ID_MAGIC_LIGHT, hm, WAIT_SEC*30,
	  1, 0, 0,
	  TIF_CHANGE_LIGHT_ADD, TIF_NONE, TIF_CHANGE_LIGHT_SUB,
	  APF_LIGHT_DARK);
   quit;
}
dilend
dilbegin sacred(medi:unitptr, tgt : unitptr, arg : string,
		    hm : integer, effect : string);
   var
    rm:unitptr;
code
{
rm:=self.outside;
secure (rm,dend);
if (rm.type!=UNIT_ST_ROOM)
  {
  act ("You must have a big area to cast this spell.",
  A_ALWAYS,self,null,null,TO_CHAR);
  unsecure (rm);
  quit;
  }
   if (isset(rm.flags, UNIT_FL_SACRED))
     quit;

   if (hm < 0)
     quit;

      hm :=(4*self.spells[SPL_SACRED])+100;
         log ("duration spell" +itoa(hm));
dilcopy("spl_sacred@basis("+itoa(hm)+")",rm);
unsecure (rm);
   quit;
   :dend:
   quit;
}
dilend

dilbegin spl_sacred (time:integer);
code
{
  set (self.flags,UNIT_FL_SACRED);
  act ("A peaceful feeling settles over this area.",
  A_ALWAYS,self.inside,null,null,TO_ALL);
  heartbeat:=PULSE_SEC*time;
  wait (SFB_TICK, TRUE);
  unset (self.flags,UNIT_FL_SACRED);
  act ("You feel the veal of protection over this area lift.",
  A_ALWAYS,self.inside,null,null,TO_ALL);
  quit;
  }
  dilend


dilbegin cont_light(medi:unitptr, tgt : unitptr, arg : string,
		    hm : integer, effect : string);
external
   integer skill_duration@basis(i : integer);

code
{
   if (isaff(tgt, ID_MAGIC_LIGHT))
     return;

   if (hm < 0)
     quit;

   hm := skill_duration(hm);

   /* 2 light sources */
   addaff(tgt, ID_MAGIC_LIGHT, 50, 0, /* Permanent */
	  2, 0, 0,
	  TIF_CHANGE_LIGHT_ADD, TIF_NONE, TIF_CHANGE_LIGHT_SUB,
	  APF_LIGHT_DARK);
   quit;
}
dilend

dilbegin darkness(medi:unitptr, tgt : unitptr, arg : string,
		  hm : integer, effect : string);
external
   integer skill_duration@basis(i : integer);

code
{
   if (isaff(tgt, ID_MAGIC_DARK))
     return;

   if (hm < 0)
     quit;

   hm := skill_duration(hm);

   /* 1 light source */
   addaff(tgt, ID_MAGIC_DARK, hm, WAIT_SEC*30,
	  -1, 0, 0,
	  TIF_CHANGE_LIGHT_SUB, TIF_NONE, TIF_CHANGE_LIGHT_ADD,
	  APF_LIGHT_DARK);
   quit;
}
dilend

dilbegin cont_darkness(medi:unitptr, tgt : unitptr, arg : string,
		       hm : integer, effect : string);
external
   integer skill_duration@basis(i : integer);

code
{
   if (isaff(tgt, ID_MAGIC_DARK))
     return;

   if (hm < 0)
     quit;

   hm := skill_duration(hm);

   /* 2 light sources */
   addaff(tgt, ID_MAGIC_DARK, 50, 0,
	  -2, 0, 0,
	  TIF_CHANGE_LIGHT_SUB, TIF_NONE, TIF_CHANGE_LIGHT_ADD,
	  APF_LIGHT_DARK);
   quit;
}
dilend

dilbegin det_align(medi:unitptr, tgt : unitptr, arg : string,
		   hm : integer, effect : string);
external
   integer skill_duration@basis(i : integer);
code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   hm := skill_duration(hm);

   addaff(tgt, ID_DETECT_ALIGN, hm, WAIT_SEC*30,
	  CHAR_DETECT_ALIGN, 0, 0,
	  TIF_EYES_TINGLE, TIF_NONE, TIF_EYES_TINGLE,
	  APF_MOD_CHAR_FLAGS);
   quit;
}
dilend


dilbegin det_invis(medi:unitptr, tgt : unitptr, arg : string,
		   hm : integer, effect : string);
external
   integer skill_duration@basis(i : integer);
code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   hm := skill_duration(hm);

   addaff(tgt, ID_DETECT_INVISIBLE, hm, WAIT_SEC*30,
	  CHAR_DETECT_INVISIBLE, 0, 0,
	  TIF_EYES_TINGLE, TIF_NONE, TIF_EYES_TINGLE,
	  APF_MOD_CHAR_FLAGS);
   quit;
}
dilend


dilbegin det_magic(medi:unitptr, tgt : unitptr, arg : string,
		   hm : integer, effect : string);
external
   integer skill_duration@basis(i : integer);
code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   hm := skill_duration(hm);

   addaff(tgt, ID_DETECT_MAGIC, hm, WAIT_SEC*30,
	  CHAR_DETECT_MAGIC, 0, 0,
	  TIF_EYES_TINGLE, TIF_NONE, TIF_EYES_TINGLE,
	  APF_MOD_CHAR_FLAGS);
   quit;
}
dilend


dilbegin det_poison(medi:unitptr, tgt : unitptr, arg : string,
		    hm : integer, effect : string);
external
   integer skill_duration@basis(i : integer);
code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   hm := skill_duration(hm);

   addaff(tgt, ID_DETECT_POISON, hm, WAIT_SEC*30,
	  CHAR_DETECT_POISON, 0, 0,
	  TIF_EYES_TINGLE, TIF_NONE, TIF_EYES_TINGLE,
	  APF_MOD_CHAR_FLAGS);
   quit;
}
dilend


dilbegin det_undead(medi:unitptr, tgt : unitptr, arg : string,
		    hm : integer, effect : string);
external
   integer skill_duration@basis(i : integer);
code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   hm := skill_duration(hm);

   addaff(tgt, ID_DETECT_UNDEAD, hm, WAIT_SEC*30,
	  CHAR_DETECT_UNDEAD, 0, 0,
	  TIF_EYES_TINGLE, TIF_NONE, TIF_EYES_TINGLE,
	  APF_MOD_CHAR_FLAGS);
   quit;
}
dilend


dilbegin det_curse(medi:unitptr, tgt : unitptr, arg : string,
		   hm : integer, effect : string);
external
   integer skill_duration@basis(i : integer);
code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   hm := skill_duration(hm);

   addaff(tgt, ID_DETECT_CURSE, hm, WAIT_SEC*30,
	  CHAR_DETECT_CURSE, 0, 0,
	  TIF_EYES_TINGLE, TIF_NONE, TIF_EYES_TINGLE,
	  APF_MOD_CHAR_FLAGS);
   quit;
}
dilend


dilbegin sense_life(medi:unitptr, tgt : unitptr, arg : string,
		    hm : integer, effect : string);
external
   integer skill_duration@basis(i : integer);
code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   hm := skill_duration(hm);

   addaff(tgt, ID_DETECT_LIFE, hm, WAIT_SEC*30,
	  CHAR_DETECT_LIFE, 0, 0,
	  TIF_EYES_TINGLE, TIF_NONE, TIF_EYES_TINGLE,
	  APF_MOD_CHAR_FLAGS);
   quit;
}
dilend


dilbegin cure_light(medi:unitptr, tgt : unitptr, arg : string,
		    hm : integer, effect : string);
external
   add_hitpoints(u : unitptr, i : integer);
   integer hit_limit(i : integer);

var
  heal : integer;

code
{
   /*
      Spell Cure Light Wounds
      This spell cures minor wounds, or partly heals major wounds
      of the target character.
      */

   if ((not RACE_IS_HUMANOID(tgt.race)) and (not RACE_IS_MAMMAL(tgt.race)))
     hm := -1;

   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   heal := hit_limit(1 + hm);
   heal := heal / 8;

   add_hitpoints(tgt, heal);

   if (effect == "")
   {
      if (self != tgt)
         act("$3n looks better.", A_SOMEONE, self, null, tgt, TO_CHAR);
      act("You feel better.", A_SOMEONE, self, null, tgt, TO_VICT);
   }
   else
     effect(medi, tgt, heal);

   quit;
}
dilend


dilbegin cure_serious(medi:unitptr, tgt : unitptr, arg : string,
		      hm : integer, effect : string);
external
   add_hitpoints(u : unitptr, i : integer);
   integer hit_limit(i : integer);

var
  heal : integer;

code
{
   /*
      Spell Cure Light Wounds
      This spell cures minor wounds, or partly heals major wounds
      of the target character.
      */

   if ((not RACE_IS_HUMANOID(tgt.race)) and (not RACE_IS_MAMMAL(tgt.race)))
     hm := -1;

   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   heal := hit_limit(1 + hm);
   heal := heal / 4;

   add_hitpoints(tgt, heal);

   if (self != tgt)
      act("$3n looks better.", A_SOMEONE, self, null, tgt, TO_CHAR);
   act("You feel better.", A_SOMEONE, self, null, tgt, TO_VICT);
   quit;
}
dilend


dilbegin heal(medi:unitptr, tgt : unitptr, arg : string,
	      hm : integer, effect : string);
external
   add_hitpoints(u : unitptr, i : integer);
   integer hit_limit(i : integer);

var
  heal : integer;

code
{
   /*
      Spell Cure Light Wounds
      This spell cures minor wounds, or partly heals major wounds
      of the target character.
      */

   if ((not RACE_IS_HUMANOID(tgt.race)) and (not RACE_IS_MAMMAL(tgt.race)))
     hm := -1;

   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   heal := hit_limit(1 + hm);
   heal := heal / 2;

   add_hitpoints(tgt, heal);

   if (self != tgt)
      act("$3n looks better.", A_SOMEONE, self, null, tgt, TO_CHAR);
   act("You feel better.", A_SOMEONE, self, null, tgt, TO_VICT);
   quit;
}
dilend


dilbegin bless(medi:unitptr, tgt : unitptr, arg : string,
	       hm : integer, effect : string);
code
{
   /*
      Spell Bless:
      This spell raises the gods good attention to a character.
      With divine intervention, the characters DIV, MAG, DEX and STR
      is raised temporarily.
      */

   if ((not RACE_IS_HUMANOID(tgt.race)) and (not RACE_IS_MAMMAL(tgt.race)))
     hm := -1;

   if ((hm < 0) or isaff(tgt, ID_BLESS))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   hm := 1 + hm / 10;
   if (hm > 10) hm := 10;

   addaff(tgt, ID_BLESS, 10, WAIT_SEC*30,
	  ABIL_DIV, hm, 0, TIF_BLESS_ON, TIF_BLESS_TICK, TIF_BLESS_OFF,
	  APF_ABILITY);

   addaff(tgt, ID_BLESS, 10, WAIT_SEC*30,
	  ABIL_DEX, hm, 0, TIF_NONE, TIF_NONE, TIF_NONE,
	  APF_ABILITY);

   addaff(tgt, ID_BLESS, 10, WAIT_SEC*30,
	  ABIL_STR, hm, 0, TIF_NONE, TIF_NONE, TIF_NONE,
	  APF_ABILITY);

   addaff(tgt, ID_BLESS, 10, WAIT_SEC*30,
	  ABIL_BRA, hm, 0, TIF_NONE, TIF_NONE, TIF_NONE,
	  APF_ABILITY);

   /* act("$1n lay hands on $3n and chants softly.",
      A_SOMEONE, sa->caster, 0, sa->target, TO_NOTVICT);
      act("You lay hands on $3n and chant softly.",
      A_SOMEONE, sa->caster, 0, sa->target, TO_CHAR);
      act("$1n lay hands on you and chant softly.",
      A_SOMEONE, sa->caster, 0, sa->target, TO_VICT); */

   quit;
}
dilend


dilbegin curse(medi:unitptr, tgt : unitptr, arg : string,
	       hm : integer, effect : string);

external
   provoked_attack@basis(victim : unitptr, ch : unitptr);
   integer skill_duration@basis(hm : integer);

code
{
   /* Spell Curse:
      This spell raises the gods bad attention to a character.
      With divine intervention, the characters DIV, MAG, DEX and STR
      is lowered temporarily. The target will especialy experience
      dificulty casting spells. */

   provoked_attack(tgt, self);

   if (isaff(tgt, ID_CURSE) or (hm < 0))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   hm := skill_duration(hm);

   if (tgt.type & (UNIT_ST_PC | UNIT_ST_NPC))
   {
      addaff(tgt, ID_CURSE, hm, WAIT_SEC*30,
	     ABIL_STR, -3, 0, TIF_CURSE_ON, TIF_NONE, TIF_CURSE_OFF,
	     APF_ABILITY);

      addaff(tgt, ID_CURSE, hm, WAIT_SEC*30,
	     ABIL_DEX, -3, 0, TIF_NONE, TIF_NONE, TIF_NONE,
	     APF_ABILITY);

      addaff(tgt, ID_CURSE, hm, WAIT_SEC*30,
	     ABIL_BRA, -3, 0, TIF_NONE, TIF_NONE, TIF_NONE,
	     APF_ABILITY);

      addaff(tgt, ID_CURSE, hm, WAIT_SEC*30,
	     ABIL_CHA, -3, 0, TIF_NONE, TIF_NONE, TIF_NONE,
	     APF_ABILITY);

      addaff(tgt, ID_CURSE, hm, WAIT_SEC*30,
	     ABIL_CON, -3, 0, TIF_NONE, TIF_NONE, TIF_NONE,
	     APF_ABILITY);

      /* act("$1n lay hands on $3n and chant in a strange tounge.",
	 A_SOMEONE, sa->caster, 0, sa->target, TO_NOTVICT);
	 act("You lay hands on $3n and chant in a strange tounge.",
	 A_SOMEONE, sa->caster, 0, sa->target, TO_CHAR);
	 act("$1n lay hands on you and chant in a strange tounge.",
	 A_SOMEONE, sa->caster, 0, sa->target, TO_VICT); */

   }
   else if (tgt.type == UNIT_ST_OBJ)
   {
      addaff(tgt, ID_CURSE, hm, WAIT_SEC*30,
	     OBJ_NO_UNEQUIP, 0, 0, TIF_CURSE_ON, TIF_NONE, TIF_CURSE_OFF,
	     APF_MOD_OBJ_FLAGS);

      /* act("$1n lay hands on $3n and chant in a strange tounge.",
	 A_SOMEONE, sa->caster, 0, sa->target, TO_ROOM);
	 act("You lay hands on $3n and chant in a strange tounge.",
	 A_SOMEONE, sa->caster, 0, sa->target, TO_CHAR); */
   }
   else
     log("Curse spell error.");

   quit;
}
dilend

dilbegin raise_div(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_DIV)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_DIV, 20, WAIT_SEC*30,
	       ABIL_DIV, hm, 0, TIF_DIV_INC, TIF_NONE, TIF_DIV_DEC,
	       APF_ABILITY);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend

dilbegin raise_mag(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_MAG)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_MAG, 20, WAIT_SEC*30,
	       ABIL_MAG, hm, 0, TIF_MAG_INC, TIF_NONE, TIF_MAG_DEC,
	       APF_ABILITY);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend

dilbegin raise_str(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_STR)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_STR, 20, WAIT_SEC*30,
	       ABIL_STR, hm, 0, TIF_STR_INC, TIF_NONE, TIF_STR_DEC,
	       APF_ABILITY);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend

dilbegin raise_dex(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_DEX)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_DEX, 20, WAIT_SEC*30,
	       ABIL_DEX, hm, 0, TIF_DEX_INC, TIF_NONE, TIF_DEX_DEC,
	       APF_ABILITY);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend

dilbegin raise_con(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_CON)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_CON, 20, WAIT_SEC*30,
	       ABIL_CON, hm, 0, TIF_CON_INC, TIF_NONE, TIF_CON_DEC,
	       APF_ABILITY);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend
dilbegin raise_cha(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_CHA)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_CHA, 20, WAIT_SEC*30,
	       ABIL_CHA, hm, 0, TIF_CHA_INC, TIF_NONE, TIF_CHA_DEC,
	       APF_ABILITY);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend

dilbegin raise_bra(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_BRA)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_BRA, 20, WAIT_SEC*30,
	       ABIL_BRA, hm, 0, TIF_BRA_INC, TIF_NONE, TIF_BRA_DEC,
	       APF_ABILITY);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend


dilbegin raise_divine(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_DIVINE)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_DIVINE, 20, WAIT_SEC*30,
	       SPL_DIVINE, hm, 0, TIF_PROTECT_INC, TIF_NONE, TIF_PROTECT_DEC,
	       APF_SPELL_ADJ);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend

dilbegin raise_heat(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_HEAT)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_HEAT, 20, WAIT_SEC*30,
	       SPL_HEAT, hm, 0, TIF_PROTECT_INC, TIF_NONE, TIF_PROTECT_DEC,
	       APF_SPELL_ADJ);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend

dilbegin raise_summoning(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_SUMMONING)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_SUMMONING, 20, WAIT_SEC*30,
	       SPL_SUMMONING, hm, 0, TIF_PROTECT_INC, TIF_NONE, TIF_PROTECT_DEC,
	       APF_SPELL_ADJ);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend

dilbegin raise_cold(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_COLD)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_COLD, 20, WAIT_SEC*30,
	       SPL_COLD, hm, 0, TIF_PROTECT_INC, TIF_NONE, TIF_PROTECT_DEC,
	       APF_SPELL_ADJ);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend

dilbegin raise_elect(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_CELL)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_CELL, 20, WAIT_SEC*30,
	       SPL_CELL, hm, 0, TIF_PROTECT_INC, TIF_NONE, TIF_PROTECT_DEC,
	       APF_SPELL_ADJ);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend

dilbegin raise_poison(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_INTERNAL)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_INTERNAL, 20, WAIT_SEC*30,
	       SPL_INTERNAL, hm, 0, TIF_PROTECT_INC, TIF_NONE, TIF_PROTECT_DEC,
	       APF_SPELL_ADJ);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend

dilbegin raise_acid(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_EXTERNAL)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_EXTERNAL, 20, WAIT_SEC*30,
	       SPL_EXTERNAL, hm, 0, TIF_PROTECT_INC, TIF_NONE, TIF_PROTECT_DEC,
	       APF_SPELL_ADJ);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend

dilbegin mind_shield(medi:unitptr, tgt : unitptr, arg : string,
	           hm : integer, effect : string);
code
{

if ((isaff(tgt,ID_SPL_RAISE_MIND)) or
(hm<0))
   {
	 if (tgt!=self)
	   act ("The magic disapates as it is cast on $2n",
		A_ALWAYS,self,tgt,null,TO_CHAR);
	 else
	   act ("The magic disapates as it is cast on you.",
		A_ALWAYS,self,tgt,null,TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
         quit;
         }

      hm := hm/10+1;
      if (hm>10)
	hm := 10;

	addaff(tgt, ID_SPL_RAISE_MIND, 20, WAIT_SEC*30,
	       SPL_MIND, hm, 0, TIF_PROTECT_INC, TIF_NONE, TIF_PROTECT_DEC,
	       APF_SPELL_ADJ);
   if (effect != "")
      effect(tgt, medi, hm);


   quit;
}
dilend


dilbegin locate_object(medi:unitptr, tgt : unitptr, arg : string,
	               hm : integer, effect : string);
external
   unitptr unit_char@basis(u : unitptr);

var
   u : unitptr;
code
{
   if (hm >=0)
   {
      act("$2n at $3t", A_SOMEONE, self, tgt, tgt.outside.title, TO_CHAR);
   }
   else
   {
      act("You feel confused.", A_ALWAYS, self, null, null, TO_CHAR);

      if (hm < -50)
      {
         u := unit_char@basis(tgt);
         act("You realize that $2n attempted to locate your $3n.",
             A_ALWAYS, u, self, tgt, TO_CHAR);
      }
   }
   quit;
}
dilend



dilbegin locate_char(medi:unitptr, targ : unitptr, arg : string,
	             hm : integer, effect : string);
code
{
   if ( (hm > 0) and RACE_IS_HUMANOID(targ.race) )
   {
      act("$2n at $3t", A_SOMEONE, self, targ, targ.outside.title, TO_CHAR);
   }
   else
   {
      act("You feel confused.", A_ALWAYS, self, null, null, TO_CHAR);

      if (hm < -25)
      {
         act("You realize that $2n attempted to locate you.",
             A_ALWAYS, targ, self, null, TO_CHAR);
      }
   }
   quit;
}
dilend



dilbegin blind(medi:unitptr, tgt : unitptr, arg : string,
	       hm : integer, effect : string);

external
   provoked_attack@basis(victim : unitptr, ch : unitptr);
   integer skill_duration@basis(hm : integer);

code
{
   provoked_attack(tgt, self);

   if (hm >= 0)
   {
      hm := skill_duration(hm);

      addaff(tgt, ID_BLIND_CHAR, hm, WAIT_SEC*30,
	     CHAR_BLIND, 0, 0, TIF_BLIND_ON, TIF_NONE, TIF_BLIND_OFF,
	     APF_MOD_CHAR_FLAGS);
   }
   quit;
}
dilend


dilbegin create_food(medi:unitptr, tgt : unitptr, arg : string,
		     hm : integer, effect : string);
var
   food : unitptr;
code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
   }
   else
   {
      food := load("magic_food@basis");
      act("You create $2n.", A_SOMEONE, self, food, null, TO_CHAR);
      act("$1n creates $2n.", A_SOMEONE, self, food, null, TO_ROOM);
   }
   quit;
}
dilend

dilbegin create_water(medi:unitptr, tgt : unitptr, arg : string,
		      hm : integer, effect : string);
var
   water : unitptr;
code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
   }
   else
   {
      water := load("magic_water@basis");
      act("You create $2n.", A_SOMEONE, self, water, null, TO_CHAR);
      act("$1n creates $2n.", A_SOMEONE, self, water, null, TO_ROOM);
   }
   quit;
}
dilend

dilbegin life_protection(medi:unitptr, tgt : unitptr, arg : string,
			 hm : integer, effect : string);
external integer skill_duration@basis(hm : integer);
code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   hm := skill_duration(hm);

   addaff(tgt, ID_LIFE_PROTECTION, hm, WAIT_SEC*60*5,
	  0, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
	  APF_NONE);

   act("$1n gestures warding signs in front of $3n.",
       A_HIDEINV, self, null, tgt, TO_NOTVICT);
   act("You protect the life force of $3n.",
       A_SOMEONE, self, null, tgt, TO_CHAR);
   act("$1n gestures in front of you and you feel your life force being "+
       "protected.",
       A_SOMEONE, self, null, tgt, TO_VICT);
   quit;
}
dilend

dilbegin energy_drain(medi:unitptr, tgt : unitptr, arg : string,
		      hm : integer, effect : string);

external
   integer skill_duration@basis(hm : integer);
   provoked_attack@basis(victim : unitptr, ch : unitptr);

code
{
   provoked_attack(tgt, self);

   if (hm < 0)
   {
      act("You fail.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (isaff(tgt, ID_LIFE_PROTECTION))
   {
      act("As you touch $3n your drainage is prevented by a life "+
	  "protection spell.",
	  A_SOMEONE, self, null, tgt, TO_CHAR);
      act("$1n touches $3n and chant in a strange tounge with no result.",
	  A_SOMEONE, self, null, tgt, TO_NOTVICT);
      act("$1n tries to drain your energy but your life force is protected.",
	  A_SOMEONE, self, null, tgt, TO_VICT);
      subaff(tgt, ID_LIFE_PROTECTION);
      quit;
   }

   hm := skill_duration(hm);
   addaff(tgt, ID_ENERGY_DRAIN, hm, WAIT_SEC*30,
	  ABIL_STR, -5, 0, TIF_NONE, TIF_NONE, TIF_NONE,
	  APF_ABILITY);

   addaff(tgt, ID_ENERGY_DRAIN, hm, WAIT_SEC*30,
	  ABIL_CON, -5, 0, TIF_NONE, TIF_NONE, TIF_NONE,
	  APF_ABILITY);

   experience(-50, tgt); /* Loose XP! */

   act("$1n lay hands on $3n and chant in a strange tounge.",
       A_SOMEONE, self, null, tgt, TO_NOTVICT);
   act("You lay hands on $3n and chant in a strange tounge.",
       A_SOMEONE, self, null, tgt, TO_CHAR);
   act("$1n lay hands on you and drain your energy.",
       A_SOMEONE, self, null, tgt, TO_VICT);
   quit;
}
dilend

dilbegin word_of_recall(medi:unitptr, tgt : unitptr, arg : string,
			hm : integer, effect : string);
var s : string;
code
{
   if ((hm < 0) or dilfind("base_recall@basis", tgt))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   s := self.hometown;
   if ((s == null) or (s == ""))
     s := "temple@udgaard";

   dilcopy("base_recall@basis("+s+","+itoa(hm)+",0)", self);
   quit;
}
dilend


dilbegin total_recall(medi:unitptr, tgt : unitptr,
                      arg : string, hm : integer, effect : string);
var
   u : unitptr;
   any : integer;
   s : string;
code
{
   any := FALSE;

   if (hm < 0)
     goto nothing;

   s := self.hometown;
   if ((s == null) or (s == ""))
     s := "temple@udgaard";

   foreach (UNIT_ST_PC|UNIT_ST_NPC, u)
   {
      if (((u == self) or (u.master == self)) and
          (not dilfind("base_recall@basis", u)))
      {
	 dilcopy("base_recall@basis("+s+","+itoa(hm)+",1)", u);
	 any := TRUE;
      }
   }
   if (not any)
     goto nothing;

   quit;

   :nothing:
   act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
   quit;
}
dilend


dilbegin drowse(medi:unitptr, tgt : unitptr, arg : string,
		hm : integer, effect : string);
external provoked_attack@basis(victim : unitptr, ch : unitptr);
var
   spd : integer;
code
{
   provoked_attack(tgt, self);

   if ((hm < 0) or (tgt.speed >= 20))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   spd := tgt.speed + 8;
   if (spd > 20)
     spd := 20;

   if (isaff(tgt, ID_SPEED))
     subaff(tgt, ID_SPEED);

   addaff(tgt, ID_SPEED, 1 + hm / 25, WAIT_SEC*15,
	  spd, 0, 0, TIF_SPEED_WORSE, TIF_NONE, TIF_SPEED_BETTER,
	  APF_SPEED);
   quit;
}
dilend


dilbegin slow(medi:unitptr, tgt : unitptr, arg : string,
	      hm : integer, effect : string);
external provoked_attack@basis(victim : unitptr, ch : unitptr);
var
   spd : integer;
code
{
   provoked_attack(tgt, self);

   if ((hm < 0) or (tgt.speed >= 16))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   spd := tgt.speed + 4;
   if (spd > 16)
     spd := 16;

   if (isaff(tgt, ID_SPEED))
     subaff(tgt, ID_SPEED);

   addaff(tgt, ID_SPEED, 1 + hm / 25, WAIT_SEC*15,
	  spd, 0, 0, TIF_SPEED_WORSE, TIF_NONE, TIF_SPEED_BETTER,
	  APF_SPEED);
   quit;
}
dilend


dilbegin haste(medi:unitptr, tgt : unitptr, arg : string,
	       hm : integer, effect : string);
var
   spd : integer;
code
{
   if ((hm < 0) or (tgt.speed <= 6))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      if (effect != "")
         effect(tgt, medi, -1);
      quit;
   }

   spd := tgt.speed - 6;
   if (spd < 6)
     spd := 6;

   if (isaff(tgt, ID_SPEED))
     subaff(tgt, ID_SPEED);

   addaff(tgt, ID_SPEED, 1 + hm / 25, WAIT_SEC*15,
	  spd, 0, 0, TIF_SPEED_BETTER, TIF_NONE, TIF_SPEED_WORSE,
	  APF_SPEED);

   if (effect != "")
      effect(tgt, medi, hm);

   quit;
}
dilend


dilbegin quicken(medi:unitptr, tgt : unitptr, arg : string,
		 hm : integer, effect : string);
var
   spd : integer;
code
{
   if ((hm < 0) or (tgt.speed <= 9))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   spd := tgt.speed - 3;
   if (spd < 9)
     spd := 9;

   if (isaff(tgt, ID_SPEED))
     subaff(tgt, ID_SPEED);

   addaff(tgt, ID_SPEED, 1 + hm / 25, WAIT_SEC*15,
	  spd, 0, 0, TIF_SPEED_BETTER, TIF_NONE, TIF_SPEED_WORSE,
	  APF_SPEED);
   quit;
}
dilend


/* Improves the speed of a character by 3. Is not accumulative with other  */
/* speed spells such as haste.                                             */

dilbegin stun(medi : unitptr, tgt : unitptr, arg : string,
	      hm : integer, effect : string);
external provoked_attack@basis(victim : unitptr, ch : unitptr);

code
{
   provoked_attack(tgt, self);

   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   change_speed(tgt, PULSE_VIOLENCE);  /* Slow him by one combat round */

   act("You stun $3n.", A_ALWAYS, self, null, tgt, TO_CHAR);

   act("$1n casts a spell upon you which makes you stunned.",
       A_ALWAYS, self, null, tgt, TO_VICT);

   act("$1n casts a powerful spell which stuns $3n.",
       A_ALWAYS, self, null, tgt, TO_NOTVICT);
   quit;
}
dilend



/* Humans & Animals - really hard (see hm) */
dilbegin hold(medi : unitptr, tgt : unitptr, arg : string,
	      hm : integer, effect : string);

external provoked_attack@basis(victim : unitptr, ch : unitptr);
code
{
   provoked_attack(tgt, self);
   set_fighting(tgt, self); /* Enter combat, possibly melee */

   if ((hm < 35) or ((not RACE_IS_HUMANOID(tgt.race)) and
                    (not RACE_IS_MAMMAL(tgt.race))))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   change_speed(tgt, 5*PULSE_VIOLENCE);  /* Slow by 5 rounds */

   act("You successfully hold $3n.", A_ALWAYS, self, null, tgt, TO_CHAR);

   act("$1n engulfs you in magic leaving you unable to fight.",
       A_ALWAYS, self, null, tgt, TO_VICT);

   act("$1n casts a powerful spell which holds $3n.",
       A_ALWAYS, self, null, tgt, TO_NOTVICT);
   quit;

}
dilend


dilbegin hold_monster(medi : unitptr, tgt : unitptr,
		      arg : string,
		      hm : integer, effect : string);

external provoked_attack@basis(victim : unitptr, ch : unitptr);
code
{
   provoked_attack(tgt, self);

   if ((hm < 35) or (RACE_IS_UNDEAD(tgt.race)))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   change_speed(tgt, 5*PULSE_VIOLENCE);  /* Slow by 5 rounds */

   act("You successfully hold $3n.", A_ALWAYS, self, null, tgt, TO_CHAR);

   act("$1n engulfs you in magic leaving you unable to fight.",
       A_ALWAYS, self, null, tgt, TO_VICT);

   act("$1n casts a powerful spell which holds $3n.",
       A_ALWAYS, self, null, tgt, TO_NOTVICT);
   quit;
}
dilend


dilbegin hold_undead(medi : unitptr, tgt : unitptr,
 	       arg : string,
		     hm : integer, effect : string);

external provoked_attack@basis(victim : unitptr, ch : unitptr);
code
{
   provoked_attack(tgt, self);

   if ((hm < 35) or (not RACE_IS_UNDEAD(tgt.race)))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   change_speed(tgt, 5*PULSE_VIOLENCE);  /* Slow by 5 rounds */

   act("You successfully hold $3n.", A_ALWAYS, self, null, tgt, TO_CHAR);

   act("$1n engulfs you in magic leaving you unable to fight.",
       A_ALWAYS, self, null, tgt, TO_VICT);

   act("$1n casts a powerful spell which holds $3n.",
       A_ALWAYS, self, null, tgt, TO_NOTVICT);
   quit;
}
dilend


dilbegin calm(medi : unitptr, tgt : unitptr,
	      arg : string,
	      hm : integer, effect : string);

external provoked_attack@basis(victim : unitptr, ch : unitptr);
code
{
   if ((hm < 0) or (not isaff(tgt, ID_FEAR)))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   while (isaff(tgt, ID_FEAR))
     subaff(tgt, ID_FEAR);

   act("You feel less paranoid.", A_ALWAYS, self, null, tgt, TO_VICT);
   act("$1n seems less paranoid.", A_ALWAYS, self, null, tgt, TO_NOTVICT);
   act("$3n seems less paranoid.", A_ALWAYS, self, null, tgt, TO_CHAR);
   quit;
}
dilend


dilbegin leather_skin(medi : unitptr, tgt : unitptr,
		    arg : string,
		      hm : integer, effect : string);

external provoked_attack@basis(victim : unitptr, ch : unitptr);
code
{
   if ((hm < 0) or isaff(tgt, ID_NATURAL_ARMOUR))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   addaff(tgt, ID_NATURAL_ARMOUR, 1 + hm / 40, WAIT_SEC*75,
	  ARM_LEATHER, 0, 0, TIF_ARMOUR_ON, TIF_NONE, TIF_ARMOUR_OFF,
	  APF_NATURAL_ARMOUR);
   quit;
}
dilend


dilbegin bark_skin(medi : unitptr, tgt : unitptr,
		    arg : string,
		   hm : integer, effect : string);

code
{
   if ((hm < 0) or isaff(tgt, ID_NATURAL_ARMOUR))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   addaff(tgt, ID_NATURAL_ARMOUR, 1 + hm / 40, WAIT_SEC*60,
	  ARM_HLEATHER, 0, 0, TIF_ARMOUR_ON, TIF_NONE, TIF_ARMOUR_OFF,
	  APF_NATURAL_ARMOUR);
   quit;
}
dilend


dilbegin bone_skin(medi : unitptr, tgt : unitptr,
		    arg : string,
		   hm : integer, effect : string);

code
{
   if ((hm < 0) or isaff(tgt, ID_NATURAL_ARMOUR))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   addaff(tgt, ID_NATURAL_ARMOUR, 1 + hm / 40, WAIT_SEC*45,
	  ARM_CHAIN, 0, 0, TIF_ARMOUR_ON, TIF_NONE, TIF_ARMOUR_OFF,
	  APF_NATURAL_ARMOUR);
   quit;
}
dilend


dilbegin stone_skin(medi : unitptr, tgt : unitptr,
		    arg : string,
		    hm : integer, effect : string);

code
{
   if ((hm < 0) or isaff(tgt, ID_NATURAL_ARMOUR))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   addaff(tgt, ID_NATURAL_ARMOUR, 1 + hm / 40, WAIT_SEC*30,
	  ARM_PLATE, 0, 0, TIF_ARMOUR_ON, TIF_NONE, TIF_ARMOUR_OFF,
	  APF_NATURAL_ARMOUR);
   quit;
}
dilend



dilbegin prot_good(medi : unitptr, tgt : unitptr,
	           arg : string,
		   hm : integer, effect : string);

external integer skill_duration@basis(hm : integer);

code
{
   if ((hm < 0) or isaff(tgt, ID_PROT_GOOD))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   hm := skill_duration@basis(hm);
   addaff(tgt, ID_PROT_GOOD, hm, WAIT_SEC*30,
	  0, 0, 0, TIF_PROT_GOOD_ON, TIF_NONE, TIF_PROT_GOOD_OFF,
	  APF_NONE);
   quit;
}
dilend



dilbegin prot_evil(medi : unitptr, tgt : unitptr,
	           arg : string,
		   hm : integer, effect : string);

external integer skill_duration@basis(hm : integer);

code
{
   if ((hm < 0) or isaff(tgt, ID_PROT_EVIL))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   hm := skill_duration@basis(hm);
   addaff(tgt, ID_PROT_EVIL, hm, WAIT_SEC*30,
	  0, 0, 0, TIF_PROT_EVIL_ON, TIF_NONE, TIF_PROT_EVIL_OFF,
	  APF_NONE);
   quit;
}
dilend



dilbegin call_lightning(medi : unitptr, tgt : unitptr,
	                arg : string,
			hm : integer, effect : string);
var
   u : unitptr;

code
{
   hm := 0;
   u := self.outside;

   while (u)
   {
      if (isset(u.flags, UNIT_FL_NO_WEATHER | UNIT_FL_INDOORS))
      {
	 act("There is no access to the forces of nature from here.",
	     A_ALWAYS, self, null, null, TO_CHAR);
	 quit;
      }
      u := u.outside;
   }

   if (weather < SKY_RAINING)
   {
      act("There is no sign of a thunder storm yet.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (weather != SKY_LIGHTNING)
     hm := -50;

   hm := attack_spell(SPL_CALL_LIGHTNING, self, medi, tgt, hm);
   quit;
}
dilend


dilbegin sun_ray(medi : unitptr, tgt : unitptr,
		 arg : string,
		 hm : integer, effect : string);
var
   u : unitptr;

code
{
   hm := 0;
   u := self.outside;

   while (u)
   {
      if (isset(u.flags, UNIT_FL_NO_WEATHER | UNIT_FL_INDOORS))
      {
	 act("There is no access to the forces of nature from here.",
	     A_ALWAYS, self, null, null, TO_CHAR);
	 quit;
      }
      u := u.outside;
   }

   if (weather != SKY_CLOUDLESS)
   {
      act("The skies are not clear.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if ((mudhour < 5) or (mudhour >= 21))
   {
      act("The sun has not rised yet.",
	  A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   /* Most powerful at noon */
   if (mudhour < 12)
     hm := 18*(mudhour - 12);
   else
     hm := -15*(mudhour - 12);

   if (RACE_IS_UNDEAD(tgt.race))
     hm := hm + 100;

   hm := attack_spell(SPL_SUN_RAY, self, medi, tgt, hm);
   quit;
}
dilend



dilbegin sleep_wait();
code
{
heartbeat:=PULSE_SEC*120;
wait (SFB_TICK, TRUE);
exec ("wake",self);
exec ("stand",self);
quit;
}
dilend



dilbegin spl_command(medi : unitptr, tgt : unitptr, arg : string,
	       hm : integer, effect : string);
external provoked_attack@basis(victim : unitptr, ch : unitptr);
code
{
arg:=getword(arg);

if (arg=="quit")
  {
  if (tgt==self)
    act ("Why not use the command 'quit'",
    A_ALWAYS,self,null,null,TO_CHAR);
  else
  act ("Thats Not nice why not ask him to 'Quit'?",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (hm < 0)
  {
   act("You unsuccessfully tried to command $2n to "+arg,
       A_SOMEONE, self, tgt, null,TO_CHAR);
   act("$1n unsuccessfully tried to command $2n to "+arg,
       A_SOMEONE, self, tgt, null,TO_NOTVICT);
   act("$1n unsuccessfully tried to command you to "+arg,
       A_SOMEONE, self, null, tgt, TO_VICT);
   provoked_attack(tgt, self);
   quit;
   }

act ("You command $3n to "+arg,
       A_SOMEONE, self, null, tgt, TO_CHAR);
act ("$1n  commands you to "+arg,
       A_SOMEONE, self, null, tgt, TO_VICT);
act ("$1n  commands $3n to "+arg,
       A_SOMEONE, self, null, tgt, TO_NOTVICT);
       if ((arg=="sleep") and
       (tgt.type==UNIT_ST_NPC))
       dilcopy ("sleep_wait@basis",tgt);
       unsecure (tgt);
       exec (arg,tgt);
quit;
}
dilend

dilbegin sleep(medi : unitptr, tgt : unitptr, arg : string,
	       hm : integer, effect : string);
external provoked_attack@basis(victim : unitptr, ch : unitptr);
code
{
   provoked_attack(tgt, self);

   if (not RACE_IS_HUMANOID(tgt.race))
     goto failure;

   if (hm >= 0)
   {
      dilcopy("spl_sleep@basis("+itoa(hm)+")", tgt);
      quit;
   }

   :failure:
   act("$1n unsuccessfully tried to make you sleep.",
       A_SOMEONE, self, null, tgt, TO_VICT);

   quit;
}
dilend



dilbegin dust_devil(medi : unitptr, tgt : unitptr, arg : string,
                    hm : integer, effect : string);
var
  u : unitptr;

code
{
   if (hm < 0)
   {
      act("Dust swirl around in the air.",
          A_SOMEONE, self, null, null, TO_ALL);
      quit;
   }

   u := load("dust_devil@basis");
   link(u, self.outside);

   act("$2n is summoned before you.",
       A_HIDEINV, self, u, null, TO_CHAR);

   act("$2n is summoned before $1n",
       A_HIDEINV, self, u, null, TO_ROOM);

   dilcopy("magic_summoned@basis("+itoa(hm)+")", u);
   dilcopy("master_servant@basis()", u);
   if (isset(self.pcflags,PC_PK_RELAXED))
   dilcopy ("catchit@basis(1)",u);
   else
   dilcopy ("catchit@basis(0)",u);


   exec("follow "+self.name, u);

   quit;
}
dilend



/* Can be cast on self while asleep! */
dilbegin awaken(medi : unitptr, tgt : unitptr,
                arg : string,
		hm : integer, effect : string);
code
{
   if (hm < 0)
   {
      act("Nothing happens.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   sendto("spl_awaken "+itoa(hm), tgt);
   quit;
}
dilend



dilbegin summer_rain(medi : unitptr, tgt : unitptr,
                     arg : string,
		     hm : integer, effect : string);
var
   u : unitptr;

code
{
   if (hm < 0)
   {
      act("Nothing happens.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   u := self.outside;
   while (u)
   {
      if (isset(u.flags, UNIT_FL_NO_WEATHER | UNIT_FL_INDOORS))
      {
	 act("There is no possibility of rain here.",
	     A_ALWAYS, self, null, null, TO_CHAR);
	 quit;
      }
      u := u.outside;
   }

   foreach (UNIT_ST_PC|UNIT_ST_NPC, u)
   {
      if (u.hp < u.max_hp)
      {
         act("Warm raindrops fall upon you, cleaning your wounds.",
             A_ALWAYS, u, null, null, TO_CHAR);
         u.hp := u.hp + 6;
         if (u.hp > u.max_hp)
           u.hp := u.max_hp;
         position_update(u);
      }
      else
        act("Warm raindrops fall upon you.",
            A_ALWAYS, u, null, null, TO_CHAR);
   }
   quit;
}
dilend



/* Can be cast on self while mortally wounded to get 0 hitpoints! */
dilbegin aid(medi : unitptr, tgt : unitptr, arg : string,
	     hm : integer, effect : string);
var
   i : integer;

code
{
   if ((hm < 0) or (tgt.hp >= 0))
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   tgt.hp := hm / 20;
   position_update(tgt);

   if (tgt != self)
   {
     act("You heal $3s bleeding wounds.",
         A_SOMEONE, self, null, tgt, TO_CHAR);

     act("Your bleeding wounds are closed by $1n.",
         A_SOMEONE, self, null, tgt, TO_VICT);

     act("$1n heals the bleeding wounds on $3n.",
         A_SOMEONE, self, null, tgt, TO_NOTVICT);
   }
   else
   {
     act("Your mortal wounds are healed.",
         A_SOMEONE, self, null, null, TO_CHAR);

     act("The bleeding wounds on $1n are magically healed.",
         A_SOMEONE, self, null, null, TO_ROOM);
   }
   quit;
}
dilend


/* Called from both 'self leaving' and 'leaving' */
/* Advanced for of flee. */
dilbegin leaving(medi : unitptr, tgt : unitptr, arg : string,
		 hm : integer, effect : string);
var
   u : unitptr;
   i : integer;

code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   /* Find the room that the tgt is inside */

   u := self.outside;
   while (u.type != UNIT_ST_ROOM)
     u := u.outside;

   arg := getword(arg);

   if (arg == "north")
     i := 0;
   else if (arg == "east")
     i := 1;
   else if (arg == "south")
     i := 2;
   else if (arg == "west")
     i := 3;
   else if (arg == "up")
     i := 4;
   else if (arg == "down")
     i := 5;
   else
   {
      act("You must specify a direction to leave in.",
	  A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   if ((not u.exit_to[i]) or (u.exit_info[i] & EX_CLOSED) or
       (u.exit_to[i].movement == SECT_WATER_SAIL))
   {
      act("No such direction.",
	  A_SOMEONE, self, null, null, TO_CHAR);
      quit;
   }

   act("$1n vanishes.",
       A_HIDEINV, self, null, null, TO_ROOM);
   act("You are teleported "+arg+".",
       A_SOMEONE, self, null, null, TO_CHAR);

   link(self, u.exit_to[i]);

   act("$1n appears from thin air.",
       A_HIDEINV, self, null, null, TO_ROOM);

   exec("look", self);

   quit;
}
dilend


dilbegin raise_dead(medi : unitptr, tgt : unitptr, arg : string,
		    hm : integer, effect : string);
var
   u : unitptr;
code
{
   if ((hm < 0) or (not isaff(tgt, ID_VALHALLA)))
     goto nothing;

   foreach (UNIT_ST_OBJ, u)
   {
      if (isaff(u, ID_CORPSE) and ((" "+tgt.name+" ") in u.outside_descr))
      {
	 act("A vortex appears above you draging your soul out of "+
	     "Valhalla and back into your mutilated body. The pain is "+
             "overwhelming, everything becomes black...",
	     A_ALWAYS, tgt, null, null, TO_CHAR);
	 act("A vortex appears above $1n sucking $1s soul out of Valhalla.",
	     A_ALWAYS, tgt, null, null, TO_ROOM);

         subaff(tgt, ID_VALHALLA);

	 link(tgt, self.outside);

	 while (u.inside)
	   link(u.inside, tgt);

	 destroy(u);

	 act("$3n touches the corpse of $1n which moves and becomes alive!",
	     A_ALWAYS, tgt, null, self, TO_NOTVICT);

	 act("You restore life into the corpse of $1n.",
	     A_ALWAYS, tgt, null, self, TO_VICT);

	 tgt.hp        := 0;
	 tgt.mana      := 0;
	 tgt.endurance := 0;
	 tgt.position  := POSITION_STUNNED;
	 quit;
      }
   }

   act("You do not have $3n's corpse.",
       A_ALWAYS, self, null, tgt, TO_CHAR);
   quit;

   :nothing:
   act("Nothing happens.", A_SOMEONE, self, null, null, TO_CHAR);
   quit;
}
dilend



dilbegin resurrect(medi : unitptr, tgt : unitptr, arg : string,
		   hm : integer, effect : string);
var
   u : unitptr;
code
{
   if ((hm < 0) or (not isaff(tgt, ID_VALHALLA)))
     goto nothing;

   foreach (UNIT_ST_OBJ, u)
   {
      if (isaff(u, ID_CORPSE) and ((" "+tgt.name+" ") in u.outside_descr))
      {
	 act("A vortex appears above you draging your soul out of "+
	     "Valhalla and back into your mutilated body.",
	     A_ALWAYS, tgt, null, null, TO_CHAR);
	 act("A vortex appears above $1n sucking $1s soul out of Valhalla.",
	     A_ALWAYS, tgt, null, null, TO_ROOM);

         subaff(tgt, ID_VALHALLA);

	 link(tgt, self.outside);

	 while (u.inside)
	   link(u.inside, tgt);

	 destroy(u);

	 act("$3n touches the corpse of $1n which moves and becomes alive!",
	     A_ALWAYS, tgt, null, self, TO_NOTVICT);

	 act("You restore life into the corpse of $1n.",
	     A_ALWAYS, tgt, null, self, TO_VICT);
	 quit;
      }
   }

   act("You do not have $3n's corpse.",
       A_ALWAYS, self, null, tgt, TO_CHAR);
   quit;

   :nothing:
   act("Nothing happens.", A_SOMEONE, self, null, null, TO_CHAR);
   quit;
}
dilend


dilbegin magic_candle(medi:unitptr, tgt : unitptr, arg : string,
		     hm : integer, effect : string);
var
   orb : unitptr;
code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
   }
   else
   {
      orb := load("candle@basis");
      act("You create $2n.", A_SOMEONE, self, orb, null, TO_CHAR);
      act("$1n creates $2n.", A_SOMEONE, self, orb, null, TO_ROOM);
   }
   quit;
}
dilend

dilbegin sun_globe(medi:unitptr, tgt : unitptr, arg : string,
		     hm : integer, effect : string);
/* by Whistler */
var
   orb : unitptr;
code
{
   if (hm < 0)
   {
      act("Nothing happens.", A_ALWAYS, self, null, null, TO_CHAR);
   }
   else
   {
      orb := load("light_orb@basis");
      act("You create $2n.", A_SOMEONE, self, orb, null, TO_CHAR);
      act("$1n creates $2n.", A_SOMEONE, self, orb, null, TO_ROOM);
   }
   quit;
}
dilend

dilbegin pickpocket(arg : string);
/* by Drevar */
external
   integer skillresist@basis(aa : integer, ad : integer,
                             sa : integer, sd : integer);
   provoked_attack@basis(victim : unitptr, ch : unitptr);
var
skilla   :  integer;
skilld   :  integer;
hm       :  integer;
vict     :  unitptr;
object   :  unitptr;
willtake :  integer;
plat     :  integer;
gold     :  integer;
silv     :  integer;
copp     :  integer;
iron     :  integer;

code
{
  if ((self.type == UNIT_ST_PC) and (self.skills[SKI_PICK_POCKETS] <= 0))
  {
     act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
     quit;
  }

  object := self.inside;
  hm := 0;
  while ((object) and (hm != 2))
    {
      if ( (object.equip == WEAR_WIELD) and
           (isset(object.objectflags, OBJ_TWO_HANDS)) )
        {
          hm := 2;
          continue;
        }

      if ( (object.equip == WEAR_HOLD) or (object.equip == WEAR_WIELD) or
         (object.equip == WEAR_SHIELD) )
        {
          hm := hm + 1;
        }

      object := object.next;
    }

  if (hm == 2)
    {
       act("You must have at least one hand free to attempt that!", A_SOMEONE,
           self, null, null, TO_CHAR);
       quit;
    }


  vict := findunit(self, arg, FIND_UNIT_SURRO, null);

  if (vict == null)
    {
      act("No such person to pickpocket.",  A_SOMEONE, self, null, null,
          TO_CHAR);
      quit;
    }

   if ((vict.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC))
  {
if (not(isset (self.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless you sign the book of blood.",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (not(isset (vict.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless $2e signs the book of blood.",
  A_ALWAYS,self,vict,null,TO_CHAR);
  quit;
  }
  }


   if (self.type == UNIT_ST_PC)
     skilla := self.skills[SKI_PICK_POCKETS];
   else
     skilla := self.abilities[ABIL_DEX];

   if (vict.type == UNIT_ST_PC)
     skilld := vict.skills[SKI_PICK_POCKETS];
   else
     skilld := vict.abilities[ABIL_DEX];

   hm := skillresist@basis(self.abilities[ABIL_DEX],
                     vict.abilities[ABIL_DEX],
		     skilla, skilld);

  if (hm <= -5)
    {
      act("You are caught!", A_SOMEONE, self, null, vict, TO_CHAR);

      if (isaff(self, ID_INVISIBILITY))
        subaff(self, ID_INVISIBILITY);

      act("You catch $1n with $1s hand in your purse!", A_SOMEONE, self, null,
          vict, TO_VICT);
      act("You see $1n trying to pilfer money from $3n...$3e doesn't " +
          "seem amused!", A_SOMEONE, self, null, vict, TO_NOTVICT);
      provoked_attack@basis(vict, self);
      logcrime(self, vict, CRIME_STEALING);
      quit;
    }


  if (hm <= 0)
    {
      act("You fail to get any money from $3n, but at least no one was
watching!",
        A_SOMEONE, self, null, vict, TO_CHAR);
      quit;
    }

  if (hm <= 5)
    {
      act("You pilfer a handful of coins just as $3e turns toward you..." +
          "You have been caught!", A_SOMEONE, self, null, vict, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
        subaff(self, ID_INVISIBILITY);

      act("Arrgh!  $1n just stole some of your hard earned money!",
           A_SOMEONE, self, null, vict, TO_VICT);
      act("You see $1n swipe a handful of coins from $3n...$3e doesn't " +
          "seem amused!", A_SOMEONE, self, null, vict, TO_NOTVICT);
      willtake := (self.skills[SKI_PICK_POCKETS] / 2);
      willtake := (rnd((willtake / 4), willtake));

      plat := (((purse(vict, PLATINUM_PIECE)*willtake) / 100) * 40960);
      gold := (((purse(vict, GOLD_PIECE)*willtake) / 100) * 5120);
      silv := (((purse(vict, SILVER_PIECE)*willtake) / 100) * 640);
      copp := (((purse(vict, COPPER_PIECE)*willtake) / 100) * 80);
      iron := (((purse(vict, IRON_PIECE)*willtake) / 100) * 10);

      if (iron)
        iron := (transfermoney(vict, self, iron));
      if (copp)
        copp := (transfermoney(vict, self, copp));
      if (silv)
        silv := (transfermoney(vict, self, silv));
      if (gold)
        gold := (transfermoney(vict, self, gold));
      if (plat)
        plat := (transfermoney(vict, self, plat));

      provoked_attack@basis(vict, self);
      logcrime(self, vict, CRIME_STEALING);
      quit;
    }

  willtake := (self.skills[SKI_PICK_POCKETS] / 2);
  willtake := (rnd((willtake / 4), willtake));

  plat := (((purse(vict, PLATINUM_PIECE)*willtake) / 100) * 40960);
  gold := (((purse(vict, GOLD_PIECE)*willtake) / 100) * 5120);
  silv := (((purse(vict, SILVER_PIECE)*willtake) / 100) * 640);
  copp := (((purse(vict, COPPER_PIECE)*willtake) / 100) * 80);
  iron := (((purse(vict, IRON_PIECE)*willtake) / 100) * 10);

  if (iron)
    iron := (transfermoney(vict, self, iron));
  if (copp)
    copp := (transfermoney(vict, self, copp));
  if (silv)
    silv := (transfermoney(vict, self, silv));
  if (gold)
    gold := (transfermoney(vict, self, gold));
  if (plat)
    plat := (transfermoney(vict, self, plat));


  act("You stealthily pilfer a handful of coins from $3n's purse and " +
      "quickly deposit them in your own.",A_SOMEONE, self, null, vict,
      TO_CHAR);
  quit;

}
dilend

dilbegin peek(arg : string);

external
   integer skillresist@basis(aa : integer, ad : integer,
                             sa : integer, sd : integer);

var
   skilla : integer;
   skilld : integer;
   hm     : integer;
   targ   : unitptr;
   object  : unitptr;
code
{
  if ((self.type == UNIT_ST_PC) and (self.skills[SKI_PEEK] <= 0))
  {
    act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
    quit;
  }

  if (arg == "")
  {
    act("Who's inventory do you wish to peek at?", A_SOMEONE, self, null,
         null, TO_CHAR);
    quit;
  }

  targ := findunit(self, arg, FIND_UNIT_SURRO, null);

  if (targ == null)
  {
    act("That person is not here!", A_SOMEONE, self, null, null, TO_CHAR);
    quit;
  }

  if (targ.type &(UNIT_ST_ROOM | UNIT_ST_OBJ))
  {
    act("You don't have to peek, just look in it!", A_SOMEONE, self, null,
    null, TO_CHAR);
    quit;
  }

  if (targ == self)
  {
    act("Why don't you just use the inventory command?", A_SOMEONE, self,
         null, null, TO_CHAR);
    quit;
  }

  if (targ.position <=  POSITION_SLEEPING)
  {
    act("They won't mind if you take a little peek at the moment.",
        A_SOMEONE, self, null, null, TO_CHAR);
    goto success;
  }

  if (self.type == UNIT_ST_PC)
    skilla := self.skills[SKI_PEEK];
  else
    skilla := self.abilities[ABIL_BRA];

  if (targ.type == UNIT_ST_PC)
    skilld := targ.skills[SKI_PEEK];
  else
    skilld := targ.abilities[ABIL_BRA];

  hm := skillresist@basis(self.abilities[ABIL_BRA],
                     targ.abilities[ABIL_BRA],
		     skilla, skilld);

  if (hm < -25)
  {
    act("You clumsily attempt to see what goodies $3n has, $3e " +
         "doesn't seem to be amused.", A_SOMEONE, self, null, targ, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
        {
          subaff(self, ID_INVISIBILITY);
        }
    act("You catch $1n blatently peeking at your possessions!",
         A_SOMEONE, self, null, targ, TO_VICT);
    quit;
  }

  if (hm <= 0)
  {
    act("You can't quite make out what $3e has, but at least you were " +
    "discrete.", A_SOMEONE, self, null, targ, TO_CHAR);
    quit;
  }

  act("You manage to peek at $3s belongings.", A_SOMEONE, self, null, targ,
      TO_CHAR);

  :success:
  act("You see $3e has: ", A_SOMEONE, self, null, targ, TO_CHAR);

  hm := FALSE;

  object := targ.inside;

  while (object)
  {
     if (visible(self, object))
     {
        if (object.equip == 0)
        {
           /* Perhaps do check for each item */
           act(object.title, A_SOMEONE, self, null, targ, TO_CHAR);
           hm := TRUE;
        }
     }
     object := object.next;
  }

  if (hm == FALSE)
    act("Absolutely nothing!", A_SOMEONE, self, null, targ, TO_CHAR);

  quit;
}
dilend

dilbegin steal(arg : string);

external
  integer skillresist@basis(aa : integer, ad : integer,
                            sa : integer, sd : integer);
  provoked_attack@basis(victim : unitptr, ch : unitptr);
var
skilla  :  integer;
skilld  :  integer;
hm      :  integer;
vict    :  unitptr;
object  :  unitptr;
targ    :  unitptr;
hands   :  integer;
t       :  string;
temp    : string;
code
{
  if ((self.type == UNIT_ST_PC) and (self.skills[SKI_STEAL] <= 0))
  {
     act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
     quit;
  }

  object := self.inside;
  while ((object) and (hands != 2))
    {
      if ( ((object.equip == WEAR_WIELD) or (object.equip == WEAR_HOLD))
and
           (isset(object.objectflags, OBJ_TWO_HANDS)) )
        {
          hands := 2;
          continue;
        }

      if ( (object.equip == WEAR_HOLD) or (object.equip == WEAR_WIELD) or
         (object.equip == WEAR_SHIELD) )
        {
          hands := hands + 1;
        }
      object := object.next;
    }

  if (hands == 2)
    {
       act("You must have at least one hand free to attempt that!",
A_SOMEONE,
           self, null, null, TO_CHAR);
       quit;
    }

  if (not (" from " in arg))
    {
      act("Steal what from who?", A_SOMEONE, self, null, null,  TO_CHAR);
      quit;
    }

  /* needed for multi word names */
  t := getword(arg);
  temp := getword(arg);
  while (temp != "from")
  {
    t := (t + " " + temp);
    temp := getword(arg);
  }

  vict := findunit(self, arg, FIND_UNIT_SURRO, null);
  if (vict == null)
    {
      act("No such person to steal from.",  A_SOMEONE, self, null,  null,
          TO_CHAR);
      quit;
    }


  if ( (vict.type != UNIT_ST_PC) and (vict.type != UNIT_ST_NPC) )
    {
      act("Why bother? Just get the darn thing!", A_SOMEONE, self, null,
null,
          TO_CHAR);
      quit;
    }

   if ((vict.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC))
  {
if (not(isset (self.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless you sign the book of blood.",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (not(isset (vict.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless $2e signs the book of
blood.",
  A_ALWAYS,self,vict,null,TO_CHAR);
  quit;
  }
  }



  targ := findunit(vict, t, FIND_UNIT_IN_ME, null);

  if (targ == null)
    {
      act("You can't find that on $3n.", A_SOMEONE, self, targ, vict,
TO_CHAR);
      quit;
    }

  if (targ.objecttype == ITEM_MONEY)
    {
      act("That would take a different type of finesse, try pilfering " +
          "instead.", A_SOMEONE, self, null, vict, TO_CHAR);
      quit;
    }

  if ( (targ.equip != 0) )  /* 0 = not equipped, value not in values.h */
    {
      act("You can only steal non-equiped items!", A_SOMEONE, self, null,
           vict, TO_CHAR);
      quit;
    }

   if (targ.zoneidx == "treasure")
   {
     act("A chill runs down your spine...someone or something is watching.",
         A_ALWAYS, self, null, null, TO_CHAR);
     act("You change your mind about stealing that.", A_ALWAYS, self,
         null, null, TO_CHAR);
     quit;
   }

   if (self.type == UNIT_ST_PC)
     skilla := self.skills[SKI_STEAL];
   else
     skilla := self.abilities[ABIL_DEX];

   if (targ.type == UNIT_ST_PC)
     skilld := vict.skills[SKI_STEAL];
   else
     skilld := vict.abilities[ABIL_DEX];

   hm := skillresist@basis(self.abilities[ABIL_DEX],
                     vict.abilities[ABIL_DEX],
		     skilla, skilld);



   if (hm <= -5)
    {
      act("You are caught!", A_SOMEONE, self, targ, vict, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
        {
          subaff(self, ID_INVISIBILITY);
        }
      act("You catch $1n trying to steal your $2n!", A_SOMEONE, self, targ,
          vict, TO_VICT);
      act("You see $1n trying to steal something from $3n...$3e doesn't " +
          "seem amused!", A_SOMEONE, self, targ, vict, TO_NOTVICT);

      provoked_attack@basis(vict, self);
      logcrime(self, vict, CRIME_STEALING);
      quit;
    }

  if (hm <= 0)
    {
      act("You fail to steal $3n's $2n, but at least no one was watching!",
        A_SOMEONE, self, targ, vict, TO_CHAR);
      quit;
    }
  if (hm < 5)
    {
      act("You steal $2n from $3n just as $3e turns toward you..You have "
+
          "been caught!", A_SOMEONE, self, targ, vict, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
        {
          subaff(self, ID_INVISIBILITY);
        }
      act("Arrgh!  $1n just stole your $2n!", A_SOMEONE, self, targ, vict,
          TO_VICT);
      act("You see $1n steal something from $3n...$3e doesn't seem
amused!",
          A_SOMEONE, self, targ, vict, TO_NOTVICT);
      link(targ, self);
      provoked_attack@basis(vict, self);
      logcrime(self, vict, CRIME_STEALING);
      quit;
    }

  act("You stealthily steal $3n's $2n and quickly tuck it out of " +
      "sight!", A_SOMEONE, self, targ, vict, TO_CHAR);
  link(targ, self);
  quit;


}
dilend

dilbegin filch(arg : string);

external
   integer skillresist@basis(aa : integer, ad : integer,
                             sa : integer, sd : integer);
   provoked_attack@basis(victim : unitptr, ch : unitptr);

var
   skilla  : integer;
   skilld  : integer;
   hm      : integer;
   targ    : unitptr;
   vict    : unitptr;
   from    : string;
   object  : unitptr;
   hands   : integer;
   t       : string;
   temp    : string;
code
{
  if ((self.type == UNIT_ST_PC) and (self.skills[SKI_FILCH] <= 0))
  {
     act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
     quit;
  }

  hands := (0);
  object := self.inside;
  while ((object) and (hands != 2))
    {
      if ( ((object.equip == WEAR_WIELD) or (object.equip == WEAR_HOLD))
and
           (isset(object.objectflags, OBJ_TWO_HANDS)) )
        {
          hands := 2;
          continue;
        }

      if ( (object.equip == WEAR_HOLD) or (object.equip == WEAR_WIELD) or
           (object.equip == WEAR_SHIELD) )
        {
          hands := hands + 1;
        }
      object := object.next;
    }

  if (hands == 2)
    {
       act("You must have at least one hand free to attempt that!",
A_SOMEONE,
           self, null, null, TO_CHAR);
       quit;
    }

  if (not (" from " in arg))
    {
      act("Filch what from who?", A_SOMEONE, self, null, null,  TO_CHAR);
      quit;
    }

  /* needed for multi word names */
  t := getword(arg);
  temp := getword(arg);
  while (temp != "from")
  {
    t := (t + " " + temp);
    temp := getword(arg);
  }

  vict := findunit(self, arg, FIND_UNIT_SURRO, null);
  if (vict == null)
    {
      act("No such person to filch from.",  A_SOMEONE, self, null,  null,
          TO_CHAR);
      quit;
    }
  if ( (not(vict.type & (UNIT_ST_PC | UNIT_ST_NPC)) ))
    {
      act("Why bother? Just get the darn thing!", A_SOMEONE, self, null,
null,
          TO_CHAR);
      quit;
    }


   if ((vict.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC))
  {
if (not(isset (self.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless you sign the book of blood.",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (not(isset (vict.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless $2e signs the book of
blood.",
  A_ALWAYS,self,vict,null,TO_CHAR);
  quit;
  }
  }


  targ := findunit(vict, t, FIND_UNIT_EQUIP, null);
  if (targ == null)
    {
      act("You can't find that on $3n.", A_SOMEONE, self, targ, vict,
TO_CHAR);
      quit;
    }

  if ( (targ.equip != WEAR_FINGER_R) and (targ.equip != WEAR_FINGER_L) and
       (targ.equip != WEAR_NECK_1) and (targ.equip != WEAR_NECK_2) and
       (targ.equip != WEAR_WAIST) and (targ.equip != WEAR_WRIST_R) and
       (targ.equip != WEAR_BACK) and (targ.equip != WEAR_EAR_L) and
       (targ.equip != WEAR_EAR_R) and (targ.equip != WEAR_ANKLE_L) and
       (targ.equip != WEAR_ANKLE_R) and (targ.equip != WEAR_WRIST_L) )
    {
      act("That would be much to difficult to filch away from $3n!",
          A_SOMEONE, self, null, vict, TO_CHAR);
      quit;
    }

   if (targ.zoneidx == "treasure")
   {
     act("A chill runs down your spine...someone or something is watching.",
         A_ALWAYS, self, null, null, TO_CHAR);
     act("You change your mind about filching that.", A_ALWAYS, self,
         null, null, TO_CHAR);
     quit;
   }

   if (self.type == UNIT_ST_PC)
     skilla := self.skills[SKI_FILCH];
   else
     skilla := self.abilities[ABIL_DEX];

   if (vict.type == UNIT_ST_PC)
     skilld := vict.skills[SKI_FILCH];
   else
     skilld := vict.abilities[ABIL_DEX];

   hm := skillresist@basis(self.abilities[ABIL_DEX],
                     vict.abilities[ABIL_DEX],
		     skilla, skilld);




  if (hm <= -5)
    {
      act("You are caught!", A_SOMEONE, self, targ, vict, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
        {
          subaff(self, ID_INVISIBILITY);
        }
      act("You catch $1n trying to filch your $2n!", A_SOMEONE, self, targ,
          vict, TO_VICT);
      act("You see $1n trying to filch something from $3n...$3e doesn't " +
          "seem amused!", A_SOMEONE, self, targ, vict, TO_NOTVICT);
      provoked_attack@basis(vict, self);
      logcrime(self, vict, CRIME_STEALING);
      quit;
    }


  if (hm <= 0)
    {
      act("You fail to filch $3n's $2n, but at least no one was watching!",
        A_SOMEONE, self, targ, vict, TO_CHAR);
      quit;
    }

  if (hm <= 5)
    {
      act("You filch $2n from $3n just as $3e turns toward you..You have "
+
          "been caught!", A_SOMEONE, self, targ, vict, TO_CHAR);
      if (isaff(self, ID_INVISIBILITY))
        {
          subaff(self, ID_INVISIBILITY);
        }
      act("Arrgh!  $1n just stole your $2n!", A_SOMEONE, self, targ, vict,
          TO_VICT);
      act("You see $1n filch something from $3n...$3e doesn't seem
amused!",
          A_SOMEONE, self, targ, vict, TO_NOTVICT);
      link(targ, self);
      provoked_attack@basis(vict, self);
      logcrime(self, vict, CRIME_STEALING);
      quit;
    }

  act("You stealthily filch $3n's $2n and quickly tuck it out of " +
      "sight!", A_SOMEONE, self, targ, vict, TO_CHAR);
  link(targ, self);
  quit;


}
dilend


dilbegin recall zombie_summoned(pwr : integer);
var
  d : integer;
  u:unitptr;
  parse : stringlist;

code
{
   interrupt(SFB_DEAD, activator == self, vanish);

   heartbeat := PULSE_SEC * 10;
   d := pwr / 15 + 2;

   while (d > 0)
   {
      :loop:
      wait(SFB_TICK | SFB_MSG, TRUE);

      if (command(CMD_AUTO_TICK))
      {
         d := d - 1;
      }
      else
      {
	 parse := getwords(argument);
	 if (parse.[0] == "spl_dispel")
	 {
	    if (atoi(parse.[1]) >= pwr)
	      goto loop;
	 }
      }
   }

   :vanish:
u:=load ("dust_bones@basis");
link (u,self.outside);

while (self.inside!=null)
link (self.inside,u);
   act ("$1n crumbles to dust.",
       A_SOMEONE, self, null, null, TO_ROOM);

   destroy(self);
}
dilend

dilbegin animate(medi : unitptr, tgt : unitptr, arg : string,
		      hm : integer, effect : string);
var
   u : unitptr;
  chk : integer;
code
{
   if (hm < 0)
   {
   act ("$1n quivers a bit and then lies still.",
   A_ALWAYS,tgt,null,null,TO_ALL);
      quit;
   }

   if (tgt.nameidx+"@"+tgt.zoneidx!="corpse@basis")
  {
  act ("You try to bring life to $2n but nothing happens",
  A_ALWAYS,self,tgt,null,TO_CHAR);
  act ("$1n tries to bring life to $2n but nothing happens",
  A_SOMEONE,self,tgt,null,TO_REST);
  quit;
  }
  chk := (tgt.value[4]);

  if ( ((chk > RACE_OTHER_MAMMAL) and (chk <= RACE_OTHER_INSECT)) or
       ((chk > RACE_OTHER_CREATURE) and (chk <= RACE_OTHER_UNDEAD)) or
       (chk == RACE_SCORPION) or (chk == RACE_CAVE_WIGHT) or
       (chk == RACE_STONE_RENDER) or (chk == RACE_VAMPIRE) or
       (chk == RACE_AUTOMATON) or (chk == RACE_SLIME) or
       (chk == RACE_LESSER_DEMON) or (chk == RACE_GREATER_DEMON) or
       (chk == RACE_LESSER_DEVIL) or (chk == RACE_GREATER_DEVIL) or
       (chk == RACE_SHADOW_DEVIL) or (chk == RACE_ARCH_DEVIL) or
       (chk == RACE_MEDUSA) or (chk == RACE_GARGOYLE) or
       (chk == RACE_GOLEM) or (chk == RACE_YOGOLOTH) or
       (chk == RACE_MIST_DWELLER) or (chk == RACE_ELEMENTAL_AIR) or
       (chk == RACE_ELEMENTAL_FIRE) or (chk == RACE_ELEMENTAL_EARTH) or
       (chk == RACE_ELEMENTAL_FROST) or (chk == RACE_ELEMENTAL_WATER) or
       (chk == RACE_ELEMENTAL_LIGHT) )
  {
   act("The corpse glows briefly then suddenly crumbles into dust...",
   A_SOMEONE, self, null,null, TO_REST);
   act("The corpse glows briefly then suddenly crumbles into dust..." +
          "something was amiss with the subject." , A_SOMEONE, self, null,
          null, TO_CHAR);

   u:=load ("dust_bones@basis");
   link (u,self.outside);
   while (tgt.inside!=null)
     link (tgt.inside, u);
unsecure (tgt);
   destroy(tgt);
   quit;
  }

   u:= load("zombie@basis");
  secure (u,lostu);
    dilcopy("undead_obey@basis("+itoa(hm)+")",u);
    dilcopy ("zombie_summoned@basis("+itoa(hm)+")",u);
    dilcopy("undead_exec@basis",u);
    dilcopy ("catchit@basis",u);

while (tgt.inside!=null)
 link (tgt.inside,u);

   link(u, self.outside);
   unsecure(u);
        act ("You animate $2n into a zombie.",
A_ALWAYS, self,tgt,null, TO_CHAR);
act ("$1n animates $2n into a zombie.",
A_SOMEONE, self,tgt,null,TO_ROOM);
unsecure (tgt);
 destroy (tgt);
   exec("follow "+self.name, u);
   :lostu:
   quit;
}
dilend




dilbegin disarm(arg : string);
/* by Drevar */
external
   integer skillresist@basis(aa : integer, ad : integer,
                             sa : integer, sd : integer);
   provoked_attack@basis(victim : unitptr, ch : unitptr);

var
   tweapon  : unitptr;
   mweapon  : unitptr;
   skilla : integer;
   skilld : integer;
   hm     : integer;
   targ   : unitptr;

code
{

  if ((self.type == UNIT_ST_PC) and (self.skills[SKI_DISARM] <= 0))
  {
     act("You must practice first.", A_ALWAYS, self, null, null, TO_CHAR);
     quit;
  }

   if (arg == "")
   {
     if (self.fighting)
     {
       targ := self.fighting;
       goto disarm;
     }
     else
     {
       act("Who do you wish to disarm?", A_SOMEONE, self, null, null,
           TO_CHAR);
       quit;
     }
   }
   targ := findunit(self, arg, FIND_UNIT_SURRO, null);

   if (targ == null)
     {
       act("They are not here!", A_SOMEONE, self, null, targ, TO_CHAR);
       quit;
     }

if (targ==self)
  {
      act("Why not use the remove command.", A_SOMEONE, self,
          null, null, TO_CHAR);
      quit;
    }


  if ( (targ.type != UNIT_ST_PC) and (targ.type != UNIT_ST_NPC) )
    {
      act("No need to disarm that, it can't attack you.", A_SOMEONE, self,
          null, null, TO_CHAR);
      quit;
    }

   if (targ.position <= POSITION_INCAP)
     {
       act("Why bother?  $3e can't hurt you now!", A_SOMEONE, self, null,
           targ, TO_CHAR);
       quit;
     }

   if ((targ.type==UNIT_ST_PC) and
   (self.type==UNIT_ST_PC))
  {
if (not(isset (self.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless you sign the book of blood.",
  A_ALWAYS,self,null,null,TO_CHAR);
  quit;
  }

if (not(isset (targ.pcflags, PC_PK_RELAXED)))
  {
  act ("You are not allowed to do this unless $2e signs the book of blood.",
  A_ALWAYS,self,targ,null,TO_CHAR);
  quit;
  }
  }

   :disarm:
   mweapon := self.inside;
   while (mweapon)
     {
       if ( (mweapon.objecttype == ITEM_WEAPON) and
            (mweapon.equip == WEAR_WIELD) )
         {
           break;
         }
       mweapon := mweapon.next;
     }

   if (mweapon == null)
     {
       act("Better get yourself a weapon first!", A_SOMEONE, self, null, null,
           TO_CHAR);
       quit;
     }

   tweapon := targ.inside;
   while (tweapon)
     {
       if ( (tweapon.objecttype == ITEM_WEAPON) and
            (tweapon.equip == WEAR_WIELD) )
         {
           break;
         }
       tweapon := tweapon.next;
     }

   if (tweapon == null)
     {
       act("$3n has no weapon!", A_SOMEONE, self, null, targ, TO_CHAR);
       quit;
     }

   provoked_attack@basis(targ, self);

   if (self.type == UNIT_ST_PC)
     skilla := self.skills[SKI_DISARM];
   else
     skilla := (self.abilities[ABIL_DEX] / 2) + (self.abilities[ABIL_STR] /2);

   if (targ.type == UNIT_ST_PC)
     skilld := targ.skills[SKI_DISARM];
   else
     skilld := (targ.abilities[ABIL_DEX] / 2) + (targ.abilities[ABIL_STR] /2);

   if (self.fighting)
     hm := skillresist@basis(
              (self.abilities[ABIL_DEX] / 4) + (self.abilities[ABIL_STR] /4),
              (targ.abilities[ABIL_DEX] / 2) + (targ.abilities[ABIL_STR] /2),
              (skilla / 2), skilld);
   else
     hm := skillresist@basis(
              (self.abilities[ABIL_DEX] / 2) + (self.abilities[ABIL_STR] /2),
              (targ.abilities[ABIL_DEX] / 2) + (targ.abilities[ABIL_STR] /2),
               skilla, skilld);


   if ((self.endurance - 2) <= 0)
     act("You are too exhausted to attempt that.", A_ALWAYS, self, null,
         null, TO_CHAR);
   else self.endurance := (self.endurance - 3);

   if (hm <= -25)
     {
        act("As you attempt to disarm $3n, your $2N slips through your " +
            "hands!", A_SOMEONE, self, mweapon, targ, TO_CHAR);
        act("$1n tries a fancy move, but you counter and cause $1m to drop
"  +
            "$1s $2N!.", A_SOMEONE, self, mweapon, targ, TO_VICT);
        act("$3n counters $1n's disarm attempt, $1n lost $1s own weapon " +
            "instead!",A_SOMEONE, self, mweapon, targ, TO_NOTVICT);
        link(mweapon, self.outside);
        if (self.type == UNIT_ST_NPC)
          dilcopy("rearm@basis("+mweapon.name+")", self);
        quit;
     }
   if (hm <= 0)
     {
       act("You attempt to disarm $3n, but fail.", A_SOMEONE, self, null,
targ,
           TO_CHAR);
       act("$1n makes a feeble attempt to relieve you of your $2N.",
           A_SOMEONE, self, tweapon, targ, TO_VICT);
       act("$1n fails $1s attempt at disarming $3n.", A_SOMEONE, self, null,
           targ, TO_NOTVICT);
       quit;
     }
   act("Your quick move pulls $3n's $2N from $3s hands!", A_SOMEONE, self,
       tweapon, targ, TO_CHAR);
   act("$1n strips your $2N from you hands!", A_SOMEONE, self, tweapon,
       targ, TO_VICT);
   act("$1n deftly strips $3n's $2N from $3s hands!", A_SOMEONE, self,
       tweapon, targ, TO_NOTVICT);
   link(tweapon, targ.outside);
   if (targ.type == UNIT_ST_NPC)
    dilcopy("rearm@basis("+tweapon.name+")", targ);
   quit;

}
dilend

dilbegin rearm(t : string);
var
i : integer;
tweap : unitptr;
code
{
  interrupt(SFB_DEAD, activator == self, stop);
  heartbeat := PULSE_VIOLENCE;

  :retry:

  wait(SFB_COM, self.position == POSITION_FIGHTING);

  heartbeat := PULSE_VIOLENCE;
  i := rnd(1, 100);
  if (i >= 40)
  {
    change_speed(self, PULSE_VIOLENCE);
    act("$1n ducks quickly and tries to recover $1s weapon.", A_SOMEONE,
        self, null, null, TO_ROOM);
    i := rnd(1, 200);
    if (i <= self.abilities[ABIL_DEX])
    {
      tweap := findunit(self, t, FIND_UNIT_SURRO, null);
      if ( (tweap) and (not isset(tweap.flags, UNIT_FL_BURIED)) )
      {
        link(tweap, self);
        act("$1n manages to retrieve $1s "+tweap.name+"", A_SOMEONE, self,
            null, null, TO_ROOM);
        exec("wield "+tweap.name+"", self);
        goto stop;
      }
      else
      {
        tweap := self.outside.inside;
        while (tweap)
        {
          if ( (tweap.type == UNIT_ST_OBJ) and
               (tweap.objecttype == ITEM_WEAPON) and
               (not isset(tweap.flags, UNIT_FL_BURIED)) )
          {
            link(tweap, self);
            act("$1n manages to retrieve a "+tweap.name+"", A_SOMEONE, self,
                null, null, TO_ROOM);
            exec("wield "+tweap.name+"", self);
            act("$1n scowls at $1s "+tweap.name+"", A_SOMEONE, self, null,
                null, TO_ROOM);
            i := 1;
            break;
          }
          else
          {
            tweap := tweap.next;
            i := 0;
          }
        }
      if (i == 0)
        act("$1n resigns to using $1s natural weapons.", A_SOMEONE, self,
            null, null, TO_ROOM);

      goto stop;
      }
    }
    else
    {
      act("$1n fumbles and fails to retrieve $1s weapon.", A_SOMEONE, self,
          null, null, TO_ROOM);
      goto retry;
    }
  }
  else
    goto retry;

  :stop:
  quit;
}
dilend

dilbegin storm_gate(medi:unitptr, tgt : unitptr, arg : string,
		    hm : integer, effect : string);
var
   p : integer;
   s : string;
code
{
   heartbeat := PULSE_SEC * 2;
   if (tgt==null)
   {
      act("Your fist glows warmly and then returns to normal.", A_ALWAYS,
self, null, null, TO_CHAR);
      act("$1n's fist glows warmly and then returns to normal.", A_ALWAYS,
self, null, null, TO_REST);
      quit;
   }
   if (hm<0)
   {
      act("A sputter and hiss is emitted from your clenched fist.",
A_ALWAYS, self, null, null, TO_CHAR);
      act("A sputter and hiss is emitted from $1n's clenched fist.",
A_ALWAYS, self, null, null, TO_REST);
      quit;
   }
   if("storm gate" in tgt.names)
   {
     pause;
     sendto("OPENCAST "+itoa(self.abilities[ABIL_BRA]), tgt);
   }
   else
   {
      act("You pretend that $2n is a Storm Gate, but you fail.", A_ALWAYS,
self, tgt, null, TO_CHAR);
      act("$1n pretends that $3n is a Storm Gate and fails.", A_ALWAYS,
self, null, tgt, TO_NOTVICT);
      act("$2n pretends that you are a Storm Gate and fails.", A_ALWAYS,
tgt, self, null,  TO_CHAR);
      quit;
   }
   quit;
}
dilend


/* ================================ o O o ================================= */




dilbegin magic(u1 : unitptr);
var
   i : integer;
code
{
   heartbeat := PULSE_SEC * 3;

   :loop:
   i  := rnd(SPL_GROUP_MAX, SPL_TREE_MAX);
   link(self, u1.outside);
   self.hp   := self.max_hp;
   self.mana := 100;
   cast_spell(i, self, self, u1);
   self.mana := 100;
   cast_spell(i, self, self, self);
   self.mana := 100;
   u1 := null;
   cast_spell(i, self, self, u1);
   return;
}
dilend


dilbegin doom(u1 : unitptr);
code
{
   heartbeat := PULSE_SEC * 3;

   :loop:
   link(self, u1.outside);
   secure(u1, done);
   exec("hit "+u1.name, self);

   while (self.fighting)
   {
      pause;
      exec("hit "+u1.name, self);
      self.hp   := self.max_hp;
      self.mana := 80;
   }

   :done:
   return;
}
dilend

%rooms

                                   ocean_void

title "The Great Ocean"
descr
"   You drifting helplessly around in the great ocean."
movement SECT_WATER_SAIL
flags {UNIT_FL_NO_WEATHER}
light 5
end


                                       void

names "void"
title "The Void"
descr
"   You are floating helplessly around in nothing. This is a very peculiar
feeling, as everything around you is nothing, not even darkness."
flags {UNIT_FL_NO_WEATHER}
light 5
end


                                   destroy_room
title "Destroy Room"
descr
"This room is used for storing units between each event that are supposed
to be extracted."
flags {UNIT_FL_NO_WEATHER, UNIT_FL_NO_TELEPORT}
light 5

end


                                   deathseq_room

title "The Death Sequence Room"
descr
"   This is the Death Sequence Room. All players that are dead and
being shown the death sequence are placed in this room."
flags {UNIT_FL_NO_TELEPORT, UNIT_FL_NO_WEATHER}
dilcopy dead_only@basis("You should not have been here, you are sent home.");
light -2  /* Always dark for players... */
end

                                     timeout

title "The Timeout Room"
descr
"   All players which are idle, are stored in this room."
flags {UNIT_FL_NO_TELEPORT, UNIT_FL_NO_WEATHER}
light 5
dilcopy dead_only@basis("You should not have been here, you are sent home.");
end


                                     entry1
/* This is where all wierd rooms meet. */

title "The Astral Plane"
descr
"   You are floating around in colours of all kinds. Below you, a bright
light is shining through a shimmering blue circle."

flags {UNIT_FL_NO_MOB, UNIT_FL_NO_WEATHER, UNIT_FL_NO_TELEPORT}
movement SECT_INSIDE
dilcopy dead_only@basis("You should not have been here, you are sent home.");
light 5
end


                                   throne_room
names {"valhalla"}
title "The Castle of Valhalla"
descr
"   You are inside the great dining hall of the Valhalla castle. Warriors
fallen in battle and others equally worthy are brought here by the Valkyries.
An exit leads east to the throne hall."
flags {UNIT_FL_NO_TELEPORT, UNIT_FL_NO_WEATHER}
dilcopy dead_only@basis("You should not have been here, you are sent home.");
light 5
east to heaven_entry;
end


                                   heaven_entry
title "The Throne Hall"
descr
"   You are inside the great throne hall of Odin. The ceiling is made of
the purest silver and in the far end of the hall is the throne of Odin,
said to let anyone sitting in it, view the entire world. The dining hall
is west."
flags {UNIT_FL_NO_TELEPORT, UNIT_FL_NO_WEATHER}
dilcopy dead_only@basis("You should not have been here, you are sent home.");
light 5
west to throne_room;
extra {"ceiling", "silver"}
"It is pure silver."
extra {"throne"}
"The throne is very large and awe inspiring, you dare not approach it."
end


                                    hell_entry
title "Burning in Hel"
descr "You are burning in Hel."
flags {UNIT_FL_NO_TELEPORT, UNIT_FL_NO_WEATHER}
dilcopy dead_only@basis("You should not have been here, you are sent home.");
light 5
end


%objects

dust_bones
names {"pile of dust","dust","pile"}
title "a pile of dust"
descr "A pile of dust and bones lies here."
MATERIAL_EARTH("Ordinary dust")

manipulate {MANIPULATE_TAKE,MANIPULATE_ENTER}
extra{}
"It looks like the remains of a zombie."
weight 50
CONTAINER_DEF(10)
dilcopy blowaway@function (600,"A sudden wind scatters a pile of dust and
bones.");
end

                              dil_master

names {"dil master", "dil"}
title "the dil master"
descr "A dil master has been left here."

manipulate {MANIPULATE_TAKE}

extra {}
"This is a dil manipulation object:&l

   zap <unit> dilname
   copy <unit> dilname

"


dilbegin dil_copy();
var
  u : unitptr;
  s : string;
  i : integer;
code
{
   wait(SFB_CMD, command("copy"));
   block;

   if (activator.level < 200)
     destroy(self);

   u := findunit(activator, argument, FIND_UNIT_HERE, null);

   if (u)
   {
      dilcopy(argument, u);
      act("Attempted to copy "+argument+" to unit "+u.name,
          A_ALWAYS, activator, null, null, TO_CHAR);
   }
   else
     act("No such unit found to copy a dil upon.",
         A_ALWAYS, activator, null, null, TO_CHAR);
}
dilend

dilbegin dil_zap();
var
  u : unitptr;
  s : string;
  i : integer;
code
{
   wait(SFB_CMD, command("zap"));
   block;

   if (activator.level < 200)
     destroy(self);

   u := findunit(activator, argument, FIND_UNIT_HERE, null);

   if (u)
   {
      s := getword(argument);
      i := dildestroy(s, u);
      if (i)
         act("DIL successfully removed.",
           A_ALWAYS, activator, null, null, TO_CHAR);
      else
         act("Unable to remove the DIL in question.",
           A_ALWAYS, activator, null, null, TO_CHAR);
   }
   else
     act("No such unit found to zap.",
         A_ALWAYS, activator, null, null, TO_CHAR);
}
dilend

end


                                porkchop
names {"pork chop", "pork", "chop"}
title "a delicious pork chop"
descr "A delicious pork chop has been left here."
manipulate {MANIPULATE_TAKE}
FOOD_DEF(36, 0)
weight 6
cost 10 IRON_PIECE
special SFUN_BLOW_AWAY time PULSE_SEC*120 bits SFB_RANTIME
"$1n returns to its origins."
end

                               mug_beer

names {"mug of tuborg", "tuborg", "mug", "beer"}
title "a mug of Tuborg"
descr "A mug of Tuborg has been dropped here."
manipulate {MANIPULATE_TAKE}
LIQ_DEF(LIQ_BEER, 1, 1, 1, 0)
weight 1
cost 7 IRON_PIECE
special SFUN_TUBORG
special SFUN_BLOW_AWAY time PULSE_SEC*120 bits SFB_RANTIME
"$1n returns to its origins."
end

                                  slime

names {"green slime", "slime", "blob"}
title "a blob of green slime"
descr "A disgusting blob of green slime has been left here."
extra {}
"As you examine the blob closer you get the eeire feeling that it
resembeles an item you once used to possess - sort of a slimy
deja-vu."
manipulate {MANIPULATE_TAKE, MANIPULATE_HOLD, MANIPULATE_ENTER}
CONTAINER_DEF(1)
weight 1
special SFUN_BLOW_AWAY "The green slime seeps into the ground."
	time WAIT_SEC*120 bits SFB_RANTIME
end


                            magic_water

names {"barrel", "water"}
title "a barrel"
descr "A barrel has been left here."
manipulate {MANIPULATE_TAKE}
LIQ_DEF(LIQ_WATER, 6, 24, 24, 0)
cost 2 IRON_PIECE
end

candle
names {"magic candle","candle"}
title "a bright magic candle."
descr "A magic candle has been discarded here."
bright 3
manipulate {MANIPULATE_HOLD, MANIPULATE_TAKE}
dilbegin candle ();
code
{
  heartbeat := PULSE_SEC*180;
  pause;
  act("Your magic candle slowly begins to dim.",
      A_SOMEONE, self.outside, null, null, TO_CHAR);
  pause;
  act("The magic candle dims to a faint glow.",
       A_SOMEONE, self.outside, null, null, TO_CHAR);
  pause;
  act("The magic candle flickers into an oblivion.",
       A_SOMEONE, self.outside, null, null, TO_CHAR);
  destroy(self);
}
dilend
end

                            light_orb
names {"yellow light globe","light globe", "globe", "light"}
title "a bright yellow globe of light"
descr "A yellow glowing globe of light has been discarded here."
bright 3
manipulate {MANIPULATE_HOLD, MANIPULATE_TAKE}
end


                             magic_food

names {"salted beef", "beef"}
title "a piece of salted beef"
descr "A piece of salted beef has been left here."
manipulate {MANIPULATE_TAKE}
FOOD_DEF(24, 0)
weight 1
cost 2 IRON_PIECE
end


                                     head
names {"head"}
title "a bloody head"
descr "The decapitated head of %s is here."
type ITEM_TRASH
manipulate {MANIPULATE_TAKE}
weight 1
end


                                     corpse
names {"corpse"}
title "a corpse"
descr "The corpse of %s is here."
type ITEM_TRASH
manipulate {MANIPULATE_TAKE, MANIPULATE_ENTER}
/* Rest of values are inserted at runtime */
dilbegin bob_code ();
var
  arg:string;
  pc:unitptr;
  pars:string;
  item:unitptr;
  ex_ptr:extraptr;
  splstr:string;
  splno:integer;
code
{
heartbeat:=PULSE_SEC*3;
if (self.value[2]!=1) quit;
interrupt (SFB_PRE,((command (CMD_CAST)) and
(target==self)),bl_animate);

:start:
unsecure(pc);
unsecure(item);
wait (SFB_CMD , command (CMD_GET));
pc:=activator;
secure (pc,start);

arg:=argument;

pars:=getword(argument);
while ((pars!="") and (pars!="from"))
  {
  pars:=getword (argument);
  }

if (pars=="") goto start;

item:=findunit (pc,argument, FIND_UNIT_SURRO,null);
if ( item ==null)
  goto start;
secure (item,start);

if (item!=self) goto start;

if ((pc.type==UNIT_ST_NPC) and
(pc.master))
{
block;
goto start;
}

if ((("corpse of "+pc.name) == item.name)) goto start;

if (not(isset (pc.pcflags, PC_PK_RELAXED)))
{
block;
act ("You can't loot other player corpses with out first signing the book.",
A_ALWAYS,pc,null,null,TO_CHAR);
goto start;
}

ex_ptr:="$BOB" in self.extra;
if (ex_ptr!=null) goto start;

:bob_block:
block;

act ("You can't loot that.", A_ALWAYS,pc,null,null,TO_CHAR);
goto start;

:bl_animate:
if (self!=target) goto start;
splstr := getword(argument);
splno := atoi(splstr);
if (splno==81)
{
power:=-1;
  block;
  act ("Making a Zombie from a fellow players corpse is forbiden.",
  A_ALWAYS,activator,null,null,TO_CHAR);
  goto start;
  }

}
dilend


end

                                iron_piece
MONEY(IRON_PIECE, 0)
/* Rest of values are inserted at runtime */
end

                                copper_piece
MONEY(COPPER_PIECE, 0)
/* Rest of values are inserted at runtime */
end

                                silver_piece
MONEY(SILVER_PIECE, 0)
/* Rest of values are inserted at runtime */
end

                                gold_piece
MONEY(GOLD_PIECE, 0)
/* Rest of values are inserted at runtime */
end

                                platinum_piece
MONEY(PLATINUM_PIECE, 0)
/* Rest of values are inserted at runtime */
end

                                       letter
names {"letter", "paper"}
title "a letter"
descr
"A letter has been left here on the ground."
type ITEM_NOTE
weight 1
manipulate MANIPULATE_TAKE
end

                                    death_seq
names {"death sequence"}
title "Death Sequence"
descr
"A death sequence has carelessly been left here."
type ITEM_TRASH
flags {UNIT_FL_NO_TELEPORT}
minv 254

/* This object is transferred to players when they die */
dilbegin noaction();
code
{
   :loop:
   wait(SFB_CMD, activator == self.outside);

   if (activator.level < IMMORTAL_LEVEL)
   {
      act("You are dead, don't move!",
          A_ALWAYS, self.outside, null, null, TO_CHAR);
      block;
   }

   goto loop;
}
dilend


dilbegin recall death_obj();
var
   i : integer;
code
{
   on_activation(self.outside.type != UNIT_ST_PC, abort);

   if ("$ARENA" in self.outside.quests)
     goto abort;

   self.outside.hp  := self.outside.max_hp;

   if (self.outside.level <= START_LEVEL + 5)
     i := 2;
   else if (self.outside.level <= 25)
     i := 4;
   else
     i := 6;

   addaff(self.outside, ID_VALHALLA, i, WAIT_SEC*30,
	  0, 0, 0, TIF_NONE, TIF_NONE, TIF_VALHALLA_RET,
	  APF_NONE);

   on_activation(not isaff(self.outside, ID_VALHALLA), abort);

   heartbeat := PULSE_SEC * 3;
   sendto ("remove kill prottection",self.outside);
dilcopy ("no_kill@basis",self.outside);

   pause;

   act("There is complete silence, you are floating in utter darkness.",
       A_ALWAYS, self.outside, null, null, TO_CHAR);
   pause;

   act("Through the darkness you see a white light in the distance.",
       A_ALWAYS, self.outside, null, null, TO_CHAR);
   pause;

   act("The light grows larger and more intense, it seems to resemble a "+
       "warrior flying through the darkness.",
       A_ALWAYS, self.outside, null, null, TO_CHAR);
   pause;

   act("The warrior takes your soul, and at that very instant you can see
the"+
       " world around you. You are in the arms of a beautiful Valkyrie, she "+
       "begins to fly towards the stars.",
       A_ALWAYS, self.outside, null, null, TO_CHAR);
   pause;

   act("The world is rapidly disappearing below you, as the Valkyrie rides "+
       "towards the stars at an amazing speed.",
       A_ALWAYS, self.outside, null, null, TO_CHAR);
   pause;

   act("After a short ride she sets your spirit down inside Valhalla. You "+
       "slowly regain a more material form.",
       A_ALWAYS, self.outside, null, null, TO_CHAR);

   act("$1n enters the castle of Valhalla",
       A_ALWAYS, self.outside, null, null, TO_ROOM);

   link(self.outside, findsymbolic("heaven_entry@basis"));

   self.outside.position := POSITION_RESTING;

   :abort:
   destroy(self);
}
dilend

end

                                     scythe

/* The ultimate weapon for the ultimate godess of death - Hel */
names {"scythe of death", "scythe"}
title "a scythe"
descr
"A great black scythe has been left here."
extra {}
"There are seven runes engraved into the blade of the scythe."
extra {"runes"}
"Each rune is very complex, and glow in a different colour."
manipulate {MANIPULATE_TAKE, MANIPULATE_WIELD}
WEAPON_DEF(WPN_SCYTHE, +25, +25)
dilcopy level_restrict@function(51,0,0,"");
end


				dictionary
names {"dictionary"}
title "a dictionary"
descr
"Someone has carelessly dropped their dictionary here."
extra {}
"On the first page of the dictionary there is a small inscription."
extra {"inscription", "first page"}
"The inscription says in ancient letters written in a shaky hand:

  You will probably get a lot more information if you type 'help alias'
                                              Kind regards, Gnort."
manipulate {MANIPULATE_TAKE, MANIPULATE_HOLD}
type ITEM_OTHER
cost 4 COPPER_PIECE
special SFUN_DICTIONARY
end

/* ============ A D M I N I S T R A T O R    O B J E C T S ============= */

				admin_obj

names {"administrator object", "object"}
title "an administrator object"
descr
"Someone has carelessly dropped an administrator object here."
extra {}
"&lThis object contains two commands:

   email
     Will send an email copy of the zone you are standing in to your
     email address. This requires that you do in fact have an email
     address registered (if not ask an administrator to set it).

   zonelist
     Will send an email copy of the current zonelist to the address
     mentioned above."
manipulate {MANIPULATE_TAKE, MANIPULATE_HOLD}
type ITEM_OTHER
special SFUN_ADMINISTRATOR
end


              				admin_slime
names {"slime object", "slime", "object"}
title "a slime object"
descr
"Someone has carelessly dropped a blob of horrible green slime here."
extra {}
"&lThis object contains the much feared slime command:

   slime (add | remove | list) <symbolic file index>

And all such units will be slimed from then on (including reset of zones,
players entering the game, etc.). Do not slime this object!

Example: slime add cloud_land/concluder"
manipulate {MANIPULATE_TAKE, MANIPULATE_HOLD}
type ITEM_OTHER
special SFUN_SLIME_ADM
end


				admin_ball
names {"crystal ball", "ball"}
title "a crystal ball"
descr
"Someone has dropped a crystal ball here."
extra {}
"&lUsage: use crystal ball <num1> <num2>

        Will find the top 10 items of type <num1> with
        maximum values of value[<num2>].

        Example: use ball 5 1
          Will find the 10 weapons with the maximum quality."

manipulate {MANIPULATE_TAKE, MANIPULATE_HOLD}
type ITEM_OTHER
special SFUN_CRYSTAL_BALL
end

/* ===================================================================== */


				log_obj
names {"log object","log","object"}
title "a log object"
descr
"Someone has dropped a few pages of the log here."
extra {}
"It's really not that easy to read.  Maybe the command `log help' will
give you more information."
manipulate {MANIPULATE_TAKE, MANIPULATE_HOLD}
type ITEM_OTHER
special SFUN_LOG_OBJECT time WAIT_SEC*3
end

				rod_error
names {"rod of error", "rod"}
title "a rod of error cancellation"
descr "A rod has carelessly been left here."
extra {}
"When this objects is held and used with the 'use rod' command all errors
in the zone will be cleared."
manipulate {MANIPULATE_TAKE, MANIPULATE_HOLD}
type ITEM_OTHER
special SFUN_ERROR_ERASE
end

				rod_info
names {"rod of info", "rod"}
title "a rod of user information cancellation"
descr "A rod has carelessly been left here."
extra {}
"When this objects is held and used with the 'wave rod' command all
information given by the players in a given zone is erased. USE ONLY
WHEN ALL USER INFO HAS BEEN READ AND CORRECTED."
manipulate {MANIPULATE_TAKE, MANIPULATE_HOLD}
type ITEM_OTHER
special SFUN_INFO_ERASE
end



%mobiles
     odin

/* God of death */
names {"odin"}
title "Odin"
descr
"Odin the almighty is sitting here in his throne."
M_NORSE_ODIN
level 199
height 190
weight 190
default POSITION_SITTING
position POSITION_SITTING

extra {}
"Beneath wild long grey hair and beard you see black calm eyes looking
back at you."

dilbegin accuse_detect();
var
  u : unitptr;
  ou : unitptr;
code
{
   heartbeat := PULSE_SEC * 10;

   :loop:
   wait(SFB_TICK, TRUE);
   u := findrndunit(self, FIND_UNIT_SURRO, UNIT_ST_PC);
   if (u and (u != ou))
   {
      if (isaff(u, ID_WITNESS))
      {
         exec("tell "+u.name+" I see you have been the victim of a "+
              "horrible crime, if you wish to accuse anyone, I can help you.",
              self);
         ou := u;
         secure(ou, loop);
         goto loop;
      }
   }
   goto loop;
}
dilend

special SFUN_ACCUSE
end


                                 heidruns

names {"heidruns", "goat"}
title "Heidruns the goat"
descr "Heidruns the magical goat is standing here."
race RACE_GOAT
attack WPN_CRUSH
sex SEX_FEMALE
extra {}
"Heidruns is a nice magical goat that anyone would appreciate at home!
Obviously she is not a normal goat since famous Tuborg beer flows from
her udder (use 'milk goat' to get a mug of Tuborg)."

dilbegin goat();
var
   u : unitptr;
code
{
   wait(SFB_CMD, command("milk"));

   if (self #= findunit(activator, argument, FIND_UNIT_SURRO, null))
   {
      if (findunit(activator, "mug", FIND_UNIT_INVEN, null))
      {
	 act("You already have a mug of beer.",
	     A_SOMEONE, activator, self, null, TO_CHAR);
      }
      else
      {
	 act("You grab a mug and milk $2n.",
	     A_SOMEONE, activator, self, null, TO_CHAR);
	 act("$1n milks $2n.",
	     A_SOMEONE, activator, self, null, TO_ROOM);
	 u := load("mug_beer@basis");
	 link(u, activator);
      }
   }
   else
   {
      act("You can only milk Heidruns the goat.",
	  A_SOMEONE, activator, self, null, TO_CHAR);
   }
   block;
}
dilend

end

                                 saerimner

names {"saerimner", "pig"}
title "Saerimner the pig"
descr "Saerimner the magical pig is standing here."

extra {}
"Saerimner is a nice little magical pig. He doesn't mind at all when
you cut porkchops from his fat little body. In fact, he regenerates
his flesh as fast as you can cut it away! (Use 'cut pig' to get food)."

sex SEX_MALE
attack WPN_BITE
race RACE_PIG

dilbegin pig();
var
   u : unitptr;
code
{
   wait(SFB_CMD, command("cut"));

   if (self #= findunit(activator, argument, FIND_UNIT_SURRO, null))
   {
      if (findunit(activator, "pork chop", FIND_UNIT_INVEN, null))
      {
	 act("You have already got a pork chop, eat it first.",
	     A_SOMEONE, activator, self, null, TO_CHAR);
      }
      else
      {
	 act("You cut a pork chop from $2n.",
	     A_SOMEONE, activator, self, null, TO_CHAR);
	 act("$2n giggles as $1n cuts a pork chop from his little fat body.",
	     A_SOMEONE, activator, self, null, TO_ROOM);
	 u := load("porkchop@basis");
	 link(u, activator);
      }
   }
   else
   {
      act("You can only cut in Saerimner the pig.",
	  A_SOMEONE, activator, self, null, TO_CHAR);
   }
   block;
}
dilend
end

%mobiles
				earth_elm

names {"earth elemental", "elemental"}
title "an earth elemental"
descr "a large, humanoid column of rock stands here."
extra {}
"The large beast is made of solid rock, with huge diamonds for eyes."

M_ELEMENTAL_FIRE
exp 0
level 13
race RACE_ELEMENTAL_EARTH
special SFUN_COMBAT_MAGIC "cast acid drop"
special SFUN_OBEY_ANIMAL
dilcopy sum_check@basis();
end


				air_elm

names {"air elemental", "elemental"}
title "an air elemental"
descr "a large, swirling mist in humanoid form floats here."
extra {}
"This being is nearly translucent, and floats in the air quietly."

M_ELEMENTAL_FIRE
exp 0
race RACE_ELEMENTAL_AIR
level 17

special SFUN_COMBAT_MAGIC "cast electrical shock"
special SFUN_OBEY_ANIMAL
dilcopy sum_check@basis();
end

				water_elm

names {"water elemental", "elemental"}
title "a water elemental"
descr "a large column of water stands here."
extra {}
"This column of water seems to be alive!"

M_ELEMENTAL_FIRE
exp 0
race RACE_ELEMENTAL_WATER
level 23

special SFUN_COMBAT_MAGIC "cast snowball"
special SFUN_OBEY_ANIMAL
dilcopy sum_check@basis();
end


				fire_elm

names {"fire elemental", "elemental"}
title "a fire elemental"
descr "a large column of flame stands here."
extra {}
"Movement from the flames suggest intelligence is present."

M_ELEMENTAL_FIRE
exp 0
level 28

special SFUN_OBEY_ANIMAL
dilcopy sum_check@basis();
end


				demon

names {"demon"}
title "a demon"
descr "a large demon stands here."
extra {}
"This large beast looks very upset at being pulled from its plane of
existance."

M_DEMON_AVG(SEX_MALE)
exp 0
level 35

special SFUN_OBEY_ANIMAL
dilcopy sum_check@basis();
end


				devil

names {"devil"}
title "a devil"
descr "a large devil stands here."
extra {}
"This large creature stands with a malevolent grin on his face."

M_DEMON_AVG(SEX_MALE)
level 45
exp 0
race RACE_LESSER_DEVIL
dilcopy sum_check@basis();
special SFUN_OBEY_ANIMAL
end


                           dust_devil

names {"dust devil", "dust", "devil"}
title "a dust devil"
descr "A small tornado of swirling dust is spinning around."
extra {}
"Watch out, you might get the dust in your eyes!"

M_DUST_DEVIL
exp 0

special SFUN_OBEY_ANIMAL
end

                           zombie

names {"zombie"}
title "the zombie"
descr "A mindless zombie is roaming around here."
extra {} "Disgusting!"
M_ZOMBIE_AVG
level 4
exp 0
end

                                      recep_daemon

names {"reception daemon", "daemon"}
title "the daemon"
descr "The dreaded reception daemon is standing here."
extra {}
"You have heard tales of this daemon before. It is a dreaded creature which
silently during the night erases all your inventory!"
romflags {CHAR_DETECT_INVISIBLE}

M_DEMON_GREATER(SEX_NEUTRAL)

special SFUN_RECEP_DAEMON time WAIT_SEC*60*3
end


                                   chaos_daemon

/* Daemon to make random events */
names {"chaos daemon", "daemon"}
title "the daemon"
descr "The dreaded Chaos daemon is standing here."
extra {}
"You have heard tales of this daemon before. It is a dreaded creature which
causes chaos in the world. Good and bad things simply happen only because of
the mere existence of this small creature."

romflags {CHAR_DETECT_INVISIBLE}

M_DEMON_GREATER(SEX_NEUTRAL)

special SFUN_CHAOS_DAEMON time WAIT_SEC*60*60 bits SFB_RANTIME
end

                                       hel
/* Godess of Hell */
names {"hel"}
title "Hel"
descr "Hel the grim reaper is here."
extra {} "Dressed in black."
romflags {CHAR_DETECT_INVISIBLE}
ATTACK_DEFENSE(+500, +500)

M_NORSE_HELA

special SFUN_COMBAT_MAGIC "cast acidball"
special SFUN_MERCENARY_HIRE


dilbegin appocalypse();
external
   magic@basis(u1 : unitptr);
   doom@basis (u1 : unitptr);
var
  u1 : unitptr;
code
{
   wait(SFB_CMD, command("doom") and (activator.level >= 255));
   block;

   heartbeat := PULSE_SEC * 3;

   :loop:
   u1 := findrndunit(self, FIND_UNIT_WORLD, UNIT_ST_NPC);
   if ((u1.idx == self.idx) or (u1 == null))
   {
      pause;
      goto loop;
   }


   if (rnd(0,1))
     magic@basis(u1);
   else if (rnd(0,1))
     doom@basis(u1);
   pause;
   goto loop;
}
dilend


end

/* Reset is only performed at boot time */

%reset

load odin into heaven_entry max 1

load hel into hell_entry max 1
{
   equip scythe position WEAR_WIELD
}
load recep_daemon into hell_entry max 1
load chaos_daemon into hell_entry max 1

load saerimner into throne_room
load heidruns into throne_room

%end

